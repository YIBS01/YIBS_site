! This file uses "f90_interface" m4 macros - plese follow corresponding rules.
! You can always look at yibs_mod.f to see how these macros were
! expanded (but don't edit that file)

include(f90_interface.m4)
define(`m4_rank_list',`0,1,2')
define(`m4_type_list',`real*8')

      module yibs_mod
!@sum this module contains the interface to YIBS dynamic vegetation model
!@+   this is the only module that should be visible to GCM
 
      ! need to know about internal structure of YIBS types
      use yibs_types, only : ycelltype, patch, cohort, timestruct,
     &     MAX_PATCHES, MAX_COHORTS, yibs_config
      use yibs_const, only : N_BANDS,N_COVERTYPES
     &     , N_OTHER, COVER_SAND
     &     , N_DEPTH,N_SOIL_TEXTURES
     &     , N_BPOOLS, N_PFT, N_CASA_LAYERS,NPOOLS,NLIVE,CARBON,PTRACE
      !use yibs_prescrveg
      use ycells
      use yibs_pfts, only : CROPS,COVEROFFSET

      !use prescr_veg ! just for compilation purposes
      implicit none

      private

      !--- public constants ---
      public N_BANDS, N_COVERTYPES 
      public N_OTHER, COVER_SAND
      public N_DEPTH, N_SOIL_TEXTURES, N_BPOOLS
      public N_PFT, N_CASA_LAYERS  !added last one -PK
      public PTRACE, NPOOLS, NLIVE, CARBON  
      public yibs_config
      public CROPS,COVEROFFSET

      public ycelltype_public, yibs_cell_pack, yibs_cell_unpack
      public yibs_get_exports, yibs_set_forcings
      public yibs_cell_construct, yibs_cell_destruct, yibs_cell_nullify
      public yibs_run,yibs_vegcover_update
      public yibs_update_veg_structure
      public yibs_cell_set, yibs_cell_set_soilcarbon !, yibs_cell_update
      public yibs_prescribe_vegupdate
      public yibs_prescribe_vegupdateB
      public yibs_prescribe_vegupdateC
      public yibs_prescribe_vegupdateD
      public yibs_init_config

      public yibs_set_forcings_r8_0

      type ycelltype_public
        private
        type(ycelltype), pointer :: ycell => null()
      end type ycelltype_public

      !---- public interfaces ---

      !--- consttructor/destructor ---
      interface yibs_cell_construct
      m4_loop(` 
        module procedure yibs_cell_construct_`'m4_suffix`'
      ')`'
      end interface

      interface yibs_cell_destruct
      m4_loop(`
        module procedure yibs_cell_destruct_`'m4_suffix`'
      ')`'
      end interface

      interface yibs_cell_nullify
      m4_loop(`
        module procedure yibs_cell_nullify_`'m4_suffix`'
      ')`'
      end interface

      interface yibs_cell_pack
      module procedure yibs_cell_pack
      module procedure yibs_cell_pack_2d
      end interface

      !--- passing initial data to yibs cells ---
      interface yibs_cell_set
      m4_loop(`
        module procedure yibs_cell_set_`'m4_suffix`'
      ')`'
      end interface

      interface yibs_cell_set_soilcarbon
      m4_loop(`
        module procedure yibs_cell_set_soilcarbon_`'m4_suffix`'
      ')`'
      end interface

#ifdef MIXED_CANOPY
      public yibs_struct_setup
      !--- passing initial data to yibs cells - mixed veg ---
      interface yibs_struct_setup
      m4_loop(`
        module procedure yibs_struct_setup_`'m4_suffix`'
      ')`'
      end interface

      public yibs_struct_initphys_cells
      !--- passing initial data to yibs cells - mixed veg ---
      interface yibs_struct_initphys_cells
      m4_loop(`
        module procedure yibs_struct_initphys_cells_`'m4_suffix`'
      ')`'
      end interface
#endif

      !--- passing updated prescribed data to yibs cells ---
cddd      interface yibs_cell_update
cddd        module procedure yibs_cell_update_single
cddd      end interface yibs_cell_update

      !--- set forcings / get exports ---
      interface yibs_set_forcings
      m4_loop(`
        module procedure yibs_set_forcings_`'m4_suffix`'
      ')`'
      end interface

      interface yibs_get_exports
      m4_loop(`
        module procedure yibs_get_exports_`'m4_suffix`'
      ')`'
      end interface

      interface yibs_run
      m4_loop(`
        module procedure yibs_run_`'m4_suffix`'
      ')`'
      end interface

      interface yibs_update_veg_structure
      m4_loop(`
        module procedure yibs_update_veg_structure_`'m4_suffix`'
      ')`'
      end interface

      interface yibs_vegcover_update
      m4_loop(`
        module procedure yibs_vegcover_update_`'m4_suffix`'
      ')`'
      end interface


!!! do we need 1d and 2d array interfaces for pack/unpack ?

      !---- private interfaces ----
      interface copy_vars
        module procedure copy_vars_single
        module procedure copy_vars_array
        module procedure copy_vars_i_single
        module procedure copy_vars_i_array
      end interface

      interface yibs_prescribe_vegupdate
      m4_loop(`
        module procedure yibs_prescribe_vegupdate_`'m4_suffix`'
      ')`'
      end interface

      interface yibs_prescribe_vegupdateB
      m4_loop(`
        module procedure yibs_prescribe_vegupdateB_`'m4_suffix`'
      ')`'
      end interface

      interface yibs_prescribe_vegupdateC
      m4_loop(`
        module procedure yibs_prescribe_vegupdateC_`'m4_suffix`'
      ')`'
      end interface

      interface yibs_prescribe_vegupdateD
      m4_loop(`
        module procedure yibs_prescribe_vegupdateD_`'m4_suffix`'
      ')`'
      end interface


      !---- global data ----
      type(yibs_config), save :: config

      contains

!*************************************************************************
      subroutine yibs_init_config(
     &     do_soilresp, do_phenology_activegrowth, do_structuralgrowth, 
     &     do_frost_hardiness, do_patchdynamics, do_init_geo)!, mixed_veg)
!@sum initializes YIBS module. This subroutine should set all the flags
!@+   and all the variables that are constant during the run.
      use yibs_const
      logical, optional :: do_soilresp
      logical, optional :: do_phenology_activegrowth
      logical, optional :: do_structuralgrowth
      logical, optional :: do_frost_hardiness
      logical, optional :: do_patchdynamics
      logical, optional :: do_init_geo
!      logical, optional :: mixed_veg

      print *, "initializing YIBS"
     &     , " N_DEPTH ", N_DEPTH 
     &     , " N_PFT ",  N_PFT
     &     , " N_SOILCOV ",  N_SOILCOV
     &     , " N_OTHER ",  N_OTHER
     &     , " N_COVERTYPES ",  N_COVERTYPES

      ! first set some defaults:
      config%do_soilresp = .false.
      config%do_phenology_activegrowth = .false.
      config%do_structuralgrowth = .false.
      config%do_frost_hardiness = .true.
      config%do_patchdynamics = .false.
!      config%mixed_veg = .false.

      ! now overwrite defaults with explicitly passed values
      if ( present(do_soilresp) ) config%do_soilresp = do_soilresp
      if ( present(do_phenology_activegrowth) ) 
     &     config%do_phenology_activegrowth = do_phenology_activegrowth
      if ( present(do_structuralgrowth) ) config%do_structuralgrowth = 
     &     do_structuralgrowth
      if ( present(do_frost_hardiness) ) config%do_frost_hardiness = 
     &     do_frost_hardiness
      if ( present(do_patchdynamics) ) config%do_patchdynamics = 
     &     do_patchdynamics
      if ( present(do_init_geo) ) config%do_init_geo = 
     &     do_init_geo
!      if ( present(mixed_veg) ) config%mixed_veg = mixed_veg

#ifdef ACTIVE_GROWTH
      config%do_phenology_activegrowth = .true.
      config%do_init_activegrowth = .true.
      config%do_frost_hardiness   = .true.
#endif

      end subroutine yibs_init_config

!*************************************************************************
!---- interfaces to run the model one time step --------------------------

m4_loop(`
      subroutine yibs_prescribe_vegupdate_`'m4_suffix`'(ycell
     &     ,hemi,jday,year,
     &     update_crops, do_giss_phenology, do_giss_lai, do_giss_albedo,
!     &     mixed_veg,
     &     laidata, hdata, albedodata, cropsdata, init)
!@sum updates prescribed vegatation parameters. This parameters can
!@+   be passed directly in form of arrays like laidata or one can
!@+   set a flag requesting certain action like do_giss_phenology.
!@+   All arguments except ycell are optional.
      use yibs_prescribed_updates, only:  ycell_vegupdate
      type(ycelltype_public),intent(inout) :: ycell m4_brkts(m4_ext)
      integer, intent(in), optional, target :: hemi m4_brkts(m4_ext)
      integer,intent(in), optional :: jday,year
      logical, intent(in), optional :: update_crops
      logical, intent(in), optional :: do_giss_phenology
      logical, intent(in), optional :: do_giss_lai
      logical, intent(in), optional :: do_giss_albedo
!      logical, intent(in), optional :: mixed_veg
      real*8, intent(in), optional, target ::
     &     laidata(:m4_comma`'m4_ext`')
      real*8, intent(in), optional, target :: hdata(:m4_comma`'m4_ext`')
      real*8, intent(in), optional, target ::
     &     albedodata(:,:m4_comma`'m4_ext`')
      real*8, intent(in), optional, target :: cropsdata m4_brkts(m4_ext)
      logical, intent(in), optional :: init !If initialization call.
      !---
      !!!real*8, allocatable :: cropsdata_loc(:,:)
      real*8, pointer :: laidata_1(:), hdata_1(:),
     &     albedodata_1(:,:), cropsdata_1
      integer :: hemi_1, jday_1
      logical :: do_giss_phenology_1, do_giss_lai_1, do_giss_albedo_1
!      logical :: mixed_veg_1
      logical :: init_1
      m4_arr_only(`integer m4_ind')`'
      m4_arr_only(`integer dims(2,m4_rank)')`'

      m4_arr_only(`dims(1,:) = lbound(ycell)')`'
      m4_arr_only(`dims(2,:) = ubound(ycell)')`'

      if ( present(update_crops) ) then
        if ( update_crops ) then
          if ( .not. present(year) )
     &      call stop_model("yibs_prescribe_vegupdate: need year",255)
          !!!allocate ( cropsdata_loc(ic,jc) )
          ! insert call to get_crops here
          ! maybe we can avoid it ? I mean could we always
          ! pass cropdata from the driver?
        endif
      endif

      ! set defaults
      nullify( laidata_1, hdata_1, albedodata_1, cropsdata_1 )
      do_giss_phenology_1 = .false.
      do_giss_lai_1 = .true.
      do_giss_albedo_1 = .false.
!      mixed_veg_1 = .false.
      hemi_1 = -32768
      jday_1 = -32768
      init_1 = .false.

      ! now set optional arguments
      if ( present(do_giss_phenology) )
     &     do_giss_phenology_1 = do_giss_phenology
      if ( present(do_giss_lai) )
     &     do_giss_lai_1 = do_giss_lai
      if ( present(do_giss_albedo) )
     &     do_giss_albedo_1 = do_giss_albedo
!      if ( present(mixed_veg) )
!     &	   mixed_veg_1 = mixed_veg     	   		    
      if ( present(jday) ) jday_1 = jday
      if ( present(init) ) init_1 = init
         
      m4_do(dims)
          ! skip uninitialized cells (no land)
        if ( associated(ycell`'m4_brkts(m4_ind)`'%ycell) ) then

          if ( present(laidata) ) laidata_1 =>
     &         laidata(:`'m4_comma`'m4_ind)
          if ( present(hdata) ) hdata_1 => hdata(:`'m4_comma`'m4_ind)
          if ( present(albedodata) ) albedodata_1 =>
     &         albedodata(:,:`'m4_comma`'m4_ind)
          if ( present(cropsdata) ) cropsdata_1 =>
     &         cropsdata`'m4_brkts(m4_ind)`'
          if ( present(hemi) ) hemi_1 = hemi`'m4_brkts(m4_ind)`'

!          write(780,*) __FILE__,__LINE__,hemi_1
          
          call ycell_vegupdate(ycell`'m4_brkts(m4_ind)`'%ycell,
     &         hemi_1,
     &         jday_1, do_giss_phenology_1, do_giss_lai_1,
     &         do_giss_albedo_1, !mixed_veg_1,
     &         laidata_1, hdata_1, albedodata_1, cropsdata_1,
     &         init_1)
        endif

      m4_enddo
      end subroutine yibs_prescribe_vegupdate_`'m4_suffix`'
')`'
     
m4_loop(`
      subroutine yibs_prescribe_vegupdateB_`'m4_suffix`'(ycell)
!@sum updates prescribed vegatation parameters. This parameters can
!@+   be passed directly in form of arrays like laidata or one can
!@+   set a flag requesting certain action like do_giss_phenology.
!@+   All arguments except ycell are optional.
      use yibs_prescribed_updates, only:  ycell_vegupdate
      type(ycelltype_public),intent(inout) :: ycell m4_brkts(m4_ext)
      !---
      !!!real*8, allocatable :: cropsdata_loc(:,:)
      real*8, pointer :: laidata_1(:), hdata_1(:),
     &     albedodata_1(:,:), cropsdata_1
      integer :: hemi_1, jday_1
      logical :: do_giss_phenology_1, do_giss_lai_1, do_giss_albedo_1
      logical :: init_1
      m4_arr_only(`integer m4_ind')`'
      m4_arr_only(`integer dims(2,m4_rank)')`'

      m4_arr_only(`dims(1,:) = lbound(ycell)')`'
      m4_arr_only(`dims(2,:) = ubound(ycell)')`'


      ! set defaults
      nullify( laidata_1, hdata_1, albedodata_1, cropsdata_1 )
      do_giss_phenology_1 = .false.
      do_giss_lai_1 = .true.
      do_giss_albedo_1 = .false.
      hemi_1 = -32768
      jday_1 = -32768
      init_1 = .false.

      ! now set optional arguments
         
      m4_do(dims)
          ! skip uninitialized cells (no land)
        if ( associated(ycell`'m4_brkts(m4_ind)`'%ycell) ) then

!          write(780,*) __FILE__,__LINE__,hemi_1
          
          call ycell_vegupdate(ycell`'m4_brkts(m4_ind)`'%ycell,
     &         hemi_1,
     &         jday_1, do_giss_phenology_1, do_giss_lai_1,
     &         do_giss_albedo_1,
     &         laidata_1, hdata_1, albedodata_1, cropsdata_1,
     &         init_1)
        endif
      m4_enddo

      end subroutine yibs_prescribe_vegupdateB_`'m4_suffix`'
')`'
     
m4_loop(`
      subroutine yibs_prescribe_vegupdateC_`'m4_suffix`'(ycell
     &     ,hemi,jday,year,
     &     do_giss_phenology, do_giss_albedo, do_giss_lai, 
     &     update_crops)
!@sum updates prescribed vegatation parameters. This parameters can
!@+   be passed directly in form of arrays like laidata or one can
!@+   set a flag requesting certain action like do_giss_phenology.
!@+   All arguments except ycell are optional.
      use yibs_prescribed_updates, only:  ycell_vegupdate
      type(ycelltype_public),intent(inout) :: ycell m4_brkts(m4_ext)
      integer, intent(in), target :: hemi m4_brkts(m4_ext)
      integer,intent(in) :: jday,year
      logical, intent(in) :: update_crops
      logical, intent(in) :: do_giss_phenology
      logical, intent(in) :: do_giss_lai
      logical, intent(in) :: do_giss_albedo
      !---
      !!!real*8, allocatable :: cropsdata_loc(:,:)
      real*8, pointer :: laidata_1(:), hdata_1(:),
     &     albedodata_1(:,:), cropsdata_1
      integer :: hemi_1, jday_1
      logical :: do_giss_phenology_1, do_giss_lai_1, do_giss_albedo_1
      logical :: init_1
      m4_arr_only(`integer m4_ind')`'
      m4_arr_only(`integer dims(2,m4_rank)')`'

      m4_arr_only(`dims(1,:) = lbound(ycell)')`'
      m4_arr_only(`dims(2,:) = ubound(ycell)')`'

      ! set defaults
      nullify( laidata_1, hdata_1, albedodata_1, cropsdata_1 )
      do_giss_phenology_1 = .false.
      do_giss_lai_1 = .true.
      do_giss_albedo_1 = .false.
      hemi_1 = -32768
      jday_1 = -32768
      init_1 = .false.

      ! now set optional arguments
          do_giss_phenology_1 = do_giss_phenology
          do_giss_lai_1 = do_giss_lai
          do_giss_albedo_1 = do_giss_albedo
          jday_1 = jday
         
      m4_do(dims)
          ! skip uninitialized cells (no land)
        if ( associated(ycell`'m4_brkts(m4_ind)`'%ycell) ) then

           hemi_1 = hemi`'m4_brkts(m4_ind)`'
!          write(780,*) __FILE__,__LINE__,hemi_1
          
          call ycell_vegupdate(ycell`'m4_brkts(m4_ind)`'%ycell,
     &         hemi_1,
     &         jday_1, do_giss_phenology_1, do_giss_lai_1,
     &         do_giss_albedo_1,
     &         laidata_1, hdata_1, albedodata_1, cropsdata_1,
     &         init_1)
        endif
      m4_enddo

      end subroutine yibs_prescribe_vegupdateC_`'m4_suffix`'
')`'
     
m4_loop(`
      subroutine yibs_prescribe_vegupdateD_`'m4_suffix`'(ycell,
     &     laidata, albedodata)
!@sum updates prescribed vegatation parameters. This parameters can
!@+   be passed directly in form of arrays like laidata or one can
!@+   set a flag requesting certain action like do_giss_phenology.
!@+   All arguments except ycell are optional.
      use yibs_prescribed_updates, only:  ycell_vegupdate
      type(ycelltype_public),intent(inout) :: ycell m4_brkts(m4_ext)
      real*8, intent(in), optional, target ::
     &     laidata(:m4_comma`'m4_ext`')
      real*8, intent(in), optional, target ::
     &     albedodata(:,:m4_comma`'m4_ext`')
      !---
      !!!real*8, allocatable :: cropsdata_loc(:,:)
      real*8, pointer :: laidata_1(:), hdata_1(:),
     &     albedodata_1(:,:), cropsdata_1
      integer :: hemi_1, jday_1
      logical :: do_giss_phenology_1, do_giss_lai_1, do_giss_albedo_1
      logical :: init_1
      m4_arr_only(`integer m4_ind')`'
      m4_arr_only(`integer dims(2,m4_rank)')`'

      m4_arr_only(`dims(1,:) = lbound(ycell)')`'
      m4_arr_only(`dims(2,:) = ubound(ycell)')`'

      ! set defaults
      nullify( laidata_1, hdata_1, albedodata_1, cropsdata_1 )
      do_giss_phenology_1 = .false.
      do_giss_lai_1 = .false.
      do_giss_albedo_1 = .false.
      hemi_1 = -32768
      jday_1 = -32768
      init_1 = .false.

      ! now set optional arguments
      m4_do(dims)
          ! skip uninitialized cells (no land)
        if ( associated(ycell`'m4_brkts(m4_ind)`'%ycell) ) then

          if (present(laidata)) laidata_1 => laidata(:`'m4_comma`'m4_ind)
          if (present(albedodata)) albedodata_1 => albedodata(:,:`'m4_comma`'m4_ind)

!          write(780,*) __FILE__,__LINE__,hemi_1
          
          call ycell_vegupdate(ycell`'m4_brkts(m4_ind)`'%ycell,
     &         hemi_1,
     &         jday_1, do_giss_phenology_1, do_giss_lai_1,
     &         do_giss_albedo_1,
     &         laidata_1, hdata_1, albedodata_1, cropsdata_1,
     &         init_1)
        endif
      m4_enddo

      end subroutine yibs_prescribe_vegupdateD_`'m4_suffix`'
')`'
     

m4_loop(`
      subroutine yibs_run_`'m4_suffix`'(ycell,dt,update_day)
      use yibs, only : yibs_integrate !yibs_integrate_GISS
!!! it is not clear yet for me how this call will be implemented ...
!@sum this call updates variable that change on a long time scale.
!@+   Right now (before real dynamic vegetation is implemented)
!@+   it should perform prescribed seasonal update of vegatation
!@+   parameters (LAI, root fraction etc.)
!@+   I think extra input parameters needed here should be passed 
!@+   as formal parameters and not be packed into ycell structure.
!@+   It seems that for prescribed variation of vegeatation
!@+   parameters we need only "jday"
!@+   Is it OK from ESMF point of view?
      !use yibs_driver, only : yibs_update_veg_structure
      type(ycelltype_public),intent(inout) :: ycell m4_brkts(m4_ext)
      real*8, intent(in) :: dt !Time step (s)
      logical, intent(in) :: update_day
!      integer, intent(in) :: jday
      !---
      m4_arr_only(`integer m4_ind')`'
      m4_arr_only(`integer dims(2,m4_rank)')`'

      m4_arr_only(`dims(1,:) = lbound(ycell)')`'
      m4_arr_only(`dims(2,:) = ubound(ycell)')`'

      m4_do(dims)
        call yibs_integrate(dt, ycell`'m4_brkts(m4_ind)`'%ycell,update_day,config)
      m4_enddo

      end subroutine yibs_run_`'m4_suffix`'
')`'



m4_loop(`
      subroutine yibs_update_veg_structure_`'m4_suffix`'(ycell)
      use yibs, only : update_veg_structure !yibs_integrate_GISS
!!! it is not clear yet for me how this call will be implemented ...
!@sum this call updates variable that change on a long time scale.
!@+   Right now (before real dynamic vegetation is implemented)
!@+   it should perform prescribed seasonal update of vegatation
!@+   parameters (LAI, root fraction etc.)
!@+   I think extra input parameters needed here should be passed 
!@+   as formal parameters and not be packed into ycell structure.
!@+   It seems that for prescribed variation of vegeatation
!@+   parameters we need only "jday"
!@+   Is it OK from ESMF point of view?
      !use yibs_driver, only : yibs_update_veg_structure
      type(ycelltype_public),intent(inout) :: ycell m4_brkts(m4_ext)
!      integer, intent(in) :: jday
      !---
      m4_arr_only(`integer m4_ind')`'
      m4_arr_only(`integer dims(2,m4_rank)')`'

      m4_arr_only(`dims(1,:) = lbound(ycell)')`'
      m4_arr_only(`dims(2,:) = ubound(ycell)')`'

      m4_do(dims)
        call update_veg_structure(
     &     ycell`'m4_brkts(m4_ind)`'%ycell,config)
      m4_enddo

      end subroutine yibs_update_veg_structure_`'m4_suffix`'
')`'







m4_loop(`
      subroutine yibs_vegcover_update_`'m4_suffix`'(ycell, jday, jyear)
      type(ycelltype_public),intent(inout) :: ycell m4_brkts(m4_ext)
      integer, intent(in) :: jday, jyear
      !---      
      m4_arr_only(`integer m4_ind')`'
      m4_arr_only(`integer dims(2,m4_rank)')`'

      m4_arr_only(`dims(1,:) = lbound(ycell)')`'
      m4_arr_only(`dims(2,:) = ubound(ycell)')`'
 
      m4_do(dims)
        ! no code for vegcover_update yet ...
      m4_enddo

      end subroutine yibs_vegcover_update_`'m4_suffix`'
')`'

!---- END interfaces to run the model one time step ----

!---- Constructor / Destructor -------------------------------------------

m4_loop(`
      subroutine yibs_cell_construct_`'m4_suffix`'(ycell)
      type(ycelltype_public),intent(inout) :: ycell m4_brkts(m4_ext)
      m4_arr_only(`integer m4_ind')`'
      m4_arr_only(`integer dims(2,m4_rank)')`'

      m4_arr_only(`dims(1,:) = lbound(ycell)')`'
      m4_arr_only(`dims(2,:) = ubound(ycell)')`'
 
      m4_do(dims)
        call ycell_construct( ycell`'m4_brkts(m4_ind)`'%ycell )
      m4_enddo

      end subroutine yibs_cell_construct_`'m4_suffix`'
')`'

m4_loop(`
      subroutine yibs_cell_destruct_`'m4_suffix`'(ycell)
      type(ycelltype_public),intent(inout) :: ycell m4_brkts(m4_ext)
      m4_arr_only(`integer m4_ind')`'
      m4_arr_only(`integer dims(2,m4_rank)')`'

      m4_arr_only(`dims(1,:) = lbound(ycell)')`'
      m4_arr_only(`dims(2,:) = ubound(ycell)')`'
 
      m4_do(dims)
        call ycell_destruct( ycell`'m4_brkts(m4_ind)`'%ycell )
      m4_enddo

      end subroutine yibs_cell_destruct_`'m4_suffix`'
')`'


m4_loop(`
      subroutine yibs_cell_nullify_`'m4_suffix`'(ycell)
      type(ycelltype_public),intent(inout):: ycell m4_brkts(m4_ext)
      m4_arr_only(`integer m4_ind')`'
      m4_arr_only(`integer dims(2,m4_rank)')`'

      m4_arr_only(`dims(1,:) = lbound(ycell)')`'
      m4_arr_only(`dims(2,:) = ubound(ycell)')`'

      m4_do(dims)
        nullify( ycell`'m4_brkts(m4_ind)`'%ycell )
      m4_enddo

      end subroutine yibs_cell_nullify_`'m4_suffix`'
')`'

!---- END of  Constructor / Destructor -----

!*************************************************************************

m4_loop(`
      subroutine yibs_cell_set_`'m4_suffix`'(ycell,
     &     jdayofyear,
     &     latitude,
     &     veg_fraction,
     &     leaf_area_index,
     &     pft_heights,
     &     pft_froots,
     &     pft_soil_type,
     &     vegalbedo,
     &     soil_texture,
     &     Ci_ini, CNC_ini, Tcan_ini, Qf_ini, Tpool_ini,
     &     pdate,hdate,
     &     reinitialize)
      type(ycelltype_public),intent(inout)::
     &                            ycell`'m4_brkts(m4_ext)`'
      real*8, dimension(:m4_comma`'m4_ext`')  ::   ! dim=N_COVERTYPES, n
     &     veg_fraction,
     &     leaf_area_index,
     &     pft_heights
      integer :: jdayofyear
      real*8, dimension(:,:)  :: pft_froots
      integer, dimension(:)  :: pft_soil_type
      real*8, dimension(:,:m4_comma`'m4_ext`')  ::  vegalbedo ! dim=N_COVERTYPES, n
      real*8, dimension(:m4_comma`'m4_ext`')  ::  soil_texture ! dim=N_SOIL_TEXTURES
      real*8 m4_arr_only(`, dimension(m4_ext)')`' ::
     &     Ci_ini, CNC_ini, Tcan_ini, Qf_ini, latitude, pdate,hdate
      real*8,dimension(:,:,:,:m4_comma`'m4_ext`') :: Tpool_ini  !soil pools, in g/m2 -PK
      logical :: reinitialize
      !---
      m4_arr_only(`integer m4_ind')`'
      m4_arr_only(`integer dims(2,m4_rank)')`'

      m4_arr_only(`dims(1,:) = lbound(ycell)')`'
      m4_arr_only(`dims(2,:) = ubound(ycell)')`'

      m4_do(dims)
          !print *,"yibs_cell_set_array_2d i,j=",i,j
        if ( associated(ycell`'m4_brkts(m4_ind)`'%ycell) ) then
!      if ( .not. associated(ecp) ) 
!     &      call stop_model("init_simple_ycell 1",255)
          !call ycell_print(6,ycell`'m4_brkts(m4_ind)`'%ycell)

          call init_simple_ycell( ycell`'m4_brkts(m4_ind)`'%ycell,
     &         jdayofyear,
     &         latitude`'m4_brkts(m4_ind)`',
     &         veg_fraction(:`'m4_comma`'m4_ind),
     &         leaf_area_index(:`'m4_comma`'m4_ind),
     &         pft_heights(:`'m4_comma`'m4_ind),
     &         pft_froots,
     &         pft_soil_type,vegalbedo(:,:`'m4_comma`'m4_ind),
     &         soil_texture(:`'m4_comma`'m4_ind),
     &         Ci_ini`'m4_brkts(m4_ind)`', CNC_ini`'m4_brkts(m4_ind)`',
     &         Tcan_ini`'m4_brkts(m4_ind)`', Qf_ini`'m4_brkts(m4_ind)`',
     &         Tpool_ini(:,:,:,:`'m4_comma`'m4_ind),
     &         pdate`'m4_brkts(m4_ind)`',hdate`'m4_brkts(m4_ind)`',
     &         reinitialize)
        endif
      m4_enddo

      end subroutine yibs_cell_set_`'m4_suffix`'
')`'

!*************************************************************************

m4_loop(`
      subroutine yibs_cell_set_soilcarbon_`'m4_suffix`'(ycell,
     &     Tpool_ini )
      type(ycelltype_public),intent(inout)::
     &                            ycell`'m4_brkts(m4_ext)`'
      real*8,dimension(:,:,:,:m4_comma`'m4_ext`') :: Tpool_ini  !g/m2 -soil C
      !---
      m4_arr_only(`integer m4_ind')`'
      m4_arr_only(`integer dims(2,m4_rank)')`'

      m4_arr_only(`dims(1,:) = lbound(ycell)')`'
      m4_arr_only(`dims(2,:) = ubound(ycell)')`'

      m4_do(dims)
          !print *,"yibs_cell_set_array_2d i,j=",i,j
        if ( associated(ycell`'m4_brkts(m4_ind)`'%ycell) ) then
!      if ( .not. associated(ecp) ) 
!     &      call stop_model("assign_ycell_soilcarbon 1",255)
          !call ycell_print(6,ycell`'m4_brkts(m4_ind)`'%ycell)
          call assign_ycell_soilcarbon( 
     &	  ycell`'m4_brkts(m4_ind)`'%ycell,
     &         Tpool_ini(:,:,:,:`'m4_comma`'m4_ind) )

        endif
      m4_enddo

      end subroutine yibs_cell_set_soilcarbon_`'m4_suffix`'
')`'


!*************************************************************************

      subroutine yibs_cell_pack_2d(dbuf, ycell)
!@sum allocate single linear arrays dbuf and pack contents of
!@+   ycells(i,j) into it
      real*8, pointer :: dbuf(:)
      type(ycelltype_public), intent(in) :: ycell(:,:)
      !---
      type real8_ptr
        real*8, pointer :: ptr(:)
      end type real8_ptr
      type(real8_ptr), dimension(:,:), allocatable :: buf2d
      integer i, j, ic, jc, dc, dcc, lsize

      ic = size(ycell, 1)
      jc = size(ycell, 2)

      allocate( buf2d(ic,jc) )
      
      dc = 0
      do j=1,jc
        do i=1,ic
          !print *,"yibs_cell_pack_2d i,j=",i,j
          nullify( buf2d(i,j)%ptr )
          if ( .not. associated(ycell(i,j)%ycell) ) cycle

          call yibs_cell_pack(buf2d(i,j)%ptr, ycell(i,j))
          dc = dc + size(buf2d(i,j)%ptr, 1) + 3 ! 3 =: i,j,size
          
        enddo
      enddo

      allocate( dbuf(dc) )
      dcc = 1
      do j=1,jc
        do i=1,ic
          if ( .not. associated( buf2d(i,j)%ptr ) ) cycle

          !print *,"yibs_cell_pack_2d i,j,dcc,lsize=",i,j,dcc,lsize
          !print *,buf2d(i,j)%ptr(1:lsize)
          lsize = size(buf2d(i,j)%ptr, 1)
          dbuf(dcc) = i; dcc = dcc+1
          dbuf(dcc) = j; dcc = dcc+1
          dbuf(dcc) = lsize; dcc = dcc+1
          dbuf(dcc:dcc+lsize-1) = buf2d(i,j)%ptr(1:lsize)
          dcc = dcc+lsize
          deallocate( buf2d(i,j)%ptr )

        enddo
      enddo

      if ( dcc-1 .ne. dc ) call stop_model("yibs_cell_pack_2d: dcc",255)
     
      deallocate( buf2d )

      end subroutine yibs_cell_pack_2d


      subroutine yibs_cell_pack(dbuf, ycell)
!@sum allocate single linear arrays dbuf and pack contents of
!@+   ycell into it
      real*8, pointer :: dbuf(:)
      type(ycelltype_public), intent(in) :: ycell ! pointer ?
      !---
      type(ycelltype), pointer :: ecp
      type(patch), pointer :: p  !@var p current patch
      type(cohort), pointer :: c !@var current cohort
      integer :: np              !@var np number of patches in the cell
      integer :: nc(MAX_PATCHES) !@var nc number of cohorts in the patch
      integer :: dc, ndbuf, nn
      real*8, pointer :: NUL(:) !@var NULL dummy pointer

      nullify(NUL)

      ! return "-1" for not associated cells
      if ( .not. associated(ycell%ycell) ) then
        allocate( dbuf(1) )
        dbuf(1) = -1.d0;
        return
      endif

      ecp => ycell%ycell

      ! first compute number of patches and cohorts in the cell
      ! this actually can be save in the cell structure 
      ! for optimization ...
      ! also count the number of real*8 values to be saved
      ndbuf = 0
      call copy_cell_vars(NUL, nn, ecp, 0); ndbuf = ndbuf + nn
      np = 0
      p => ycell%ycell%oldest      
      do while ( associated(p) )
        np = np + 1
        if ( np > MAX_PATCHES )
     &       call stop_model("yibs_cell_pack: too many patches",255)
        call copy_patch_vars(NUL, nn, p, 0); ndbuf = ndbuf + nn
        nc(np) = 0
        c => p%tallest
        do while ( associated(c) )
          nc(np) = nc(np) + 1
          if ( nc(np) > MAX_COHORTS )
     &         call stop_model("yibs_cell_pack: too many cohorts",255)
          !save cohort
          !dbuf(dc) = c%_any_value_ ; dc = dc + 1
          call copy_cohort_vars(NUL, nn, c, 0); ndbuf = ndbuf + nn
          c => c%shorter
        enddo
        p => p%younger
      enddo

      allocate( dbuf(ndbuf+1+np) ) !i.e. num reals + num int's
      dc = 0
      dbuf(dc+1) = real( np, kind(0d0) );               dc = dc + 1
      !print *,"pack ", np, dbuf(1)
      dbuf(dc+1:dc+np) = real( nc(1:np), kind(0d0) ); dc = dc + np
      !print *,"pack1 ", nc(1:np), dbuf(2:dc) 

      ! now do the real saving
      ! no need to count patches and cohorts again, but leaving it here
      ! for a while for debugging
      ! save cell vars here (if there are any...), i.e. 
      ! call copy_cell_vars(dbuf, nn, p, -1);
      call copy_cell_vars(dbuf(dc+1:), nn, ecp, -1); dc = dc + nn
      np = 0
      p => ycell%ycell%oldest      
      do while ( associated(p) )
        np = np + 1
        if ( np > MAX_PATCHES )
     &       call stop_model("yibs_cell_pack: too many patches",255)
        !save patch
        call copy_patch_vars(dbuf(dc+1:), nn, p, -1); dc = dc + nn
        nc(np) = 0
        c => p%tallest
        do while ( associated(c) )
          nc(np) = nc(np) + 1
          if ( nc(np) > MAX_COHORTS )
     &         call stop_model("yibs_cell_pack: too many cohorts",255)
          !save cohort
          call copy_cohort_vars(dbuf(dc+1:), nn, c, -1); dc = dc + nn
         c => c%shorter
        enddo
        p => p%younger
      enddo

      if ( dbuf(1) .ne. np ) then
        print *,"GGGGGGGGGGG", np, nc(1:np), "XX", dbuf
      endif

      end subroutine yibs_cell_pack

!*************************************************************************

      subroutine yibs_cell_unpack(dbuf, ycell)
! this program is not finished yet: have to assign all the pointers
      use cohorts, only : cohort_construct
      use patches, only : patch_construct
      real*8, intent(inout) :: dbuf(0:)
      type(ycelltype_public), intent(inout) :: ycell ! pointer ?
      !---
      type(ycelltype), pointer :: ecp
      type(patch), pointer :: p, pprev  !@var p current patch
      type(cohort), pointer :: c, cprev !@var current cohort
      integer :: np              !@var np number of patches in the cell
      integer, allocatable :: nc(:) !@var nc number of cohorts in the patch
      integer dc, nn
      integer i, j
      integer npdebug, ncdebug ! these are for debuging

      dc = 0

      ! doesn't seem that we need to restore anything for the cell
      np = nint( dbuf(dc) ); dc = dc + 1
      if ( np == -1 ) return  ! no data for this cell

      allocate( nc(np) )
      nc(1:np) = nint( dbuf(dc:dc+np-1) ); dc = dc + np

      if ( np <= 0 ) return  ! nothing to restore...

      ecp => ycell%ycell

      call copy_cell_vars(dbuf(dc:), nn, ecp, 1); dc = dc + nn
      nullify( pprev )
      do i=1,np
        !allocate( p )
        call patch_construct(p, ycell%ycell, 0.d0, -1)
        call copy_patch_vars(dbuf(dc:), nn, p, 1); dc = dc + nn
        p%older => pprev
        nullify( cprev)
        do j=1,nc(i)
          !allocate( c )
          call cohort_construct(c, p)
          call copy_cohort_vars(dbuf(dc:), nn, c, 1); dc = dc + nn
          c%taller => cprev
          cprev => c
        enddo
        p%shortest => cprev
        pprev => p
      enddo
      ycell%ycell%youngest => p

      ! now restore pointer lists in opposite direction
      npdebug = 0
      nullify( pprev )
      p => ycell%ycell%youngest
      do while ( associated(p) )
        p%younger => pprev
        p%cellptr => ycell%ycell
        npdebug = npdebug + 1
        if ( npdebug > np )
     &     call stop_model("yibs_cell_unpack: broken struct: np",255)
        ncdebug = 0
        nullify( cprev)
        c => p%shortest
        do while ( associated(c) )
          c%shorter => cprev
          c%pptr => p
          c%cellptr => ycell%ycell
          ncdebug = ncdebug + 1
          if ( ncdebug > nc(np-npdebug+1) )
     &      call stop_model("yibs_cell_unpack: broken struct: nc",255)
          cprev => c
          c => c%taller
        enddo
        p%tallest => cprev
        pprev => p
        p => p%older
      enddo
      ycell%ycell%oldest => pprev

      deallocate( nc )

      call summarize_ycell(ycell%ycell)

      end subroutine yibs_cell_unpack

!*************************************************************************

      subroutine copy_vars_single( buf, n, var, flag )
!@copy variable to/from buffer
!@+   !!! may need to write similar for arrays and create an interface
!@+   !!! in that case "n" will have non-trivial value
      real*8, intent(inout) :: buf(:)
      integer, intent(inout) :: n
      real*8, intent(inout):: var
!@var flag defines the actual action:
!@+     -1 copy from var to buffer
!@+      1 copy from buffer to var
!@+      0 do nothing - just return the cumulative number of elements
      integer, intent(in) :: flag
      !---
      
      n = n + 1
      if ( flag == 0 ) return

      if ( flag == -1 ) then
        buf(n) = var
      else if ( flag == 1 ) then
        var = buf(n)
      else
        call stop_model("yibs_mod:copy_vars: flag .ne. 0,-1,1",255)
      endif

      end subroutine copy_vars_single

      subroutine copy_vars_array( buf, n, var, flag )
!@copy variable to/from buffer
!@+   !!! may need to write similar for arrays and create an interface
!@+   !!! in that case "n" will have non-triial value
      real*8, intent(inout) :: buf(:)
      integer, intent(inout) :: n
      real*8, intent(inout):: var(:)
!@var flag defines the actual action:
!@+     -1 copy from var to buffer
!@+      1 copy from buffer to var
!@+      0 do nothing - just return the number of fields
      integer, intent(in) :: flag
      !---
      integer :: n0
      
      n0 = n + 1
      n = n + size(var)

      if ( flag == 0 ) return

      
      if ( flag == -1 ) then
        buf(n0:n) = var(:)
      else if ( flag == 1 ) then
        var(:) = buf(n0:n)
      else
        call stop_model("yibs_mod:copy_vars: flag .ne. 0,-1,1",255)
      endif

      end subroutine copy_vars_array

      subroutine copy_vars_i_single( buf, n, var, flag )
!@copy variable to/from buffer
!@+   !!! may need to write similar for arrays and create an interface
!@+   !!! in that case "n" will have non-triial value
      real*8, intent(inout) :: buf(:)
      integer, intent(inout) :: n
      integer, intent(inout):: var
!@var flag defines the actual action:
!@+     -1 copy from var to buffer
!@+      1 copy from buffer to var
!@+      0 do nothing - just return the number of fields
      integer, intent(in) :: flag
      !---
      
      n = n + 1
      if ( flag == 0 ) return

      if ( flag == -1 ) then
        buf(n) = real( var, kind(buf) )
      else if ( flag == 1 ) then
        var = nint( buf(n) )
      else
        call stop_model("yibs_mod:copy_vars: flag .ne. 0,-1,1",255)
      endif

      end subroutine copy_vars_i_single

      subroutine copy_vars_i_array( buf, n, var, flag )
!@copy variable to/from buffer
!@+   !!! may need to write similar for arrays and create an interface
!@+   !!! in that case "n" will have non-triial value
      real*8, intent(inout) :: buf(:)
      integer, intent(inout) :: n
      integer, intent(inout):: var(:)
!@var flag defines the actual action:
!@+     -1 copy from var to buffer
!@+      1 copy from buffer to var
!@+      0 do nothing - just return the number of fields
      integer, intent(in) :: flag
      !---
      integer :: n0
      
      n0 = n + 1
      n = n + size(var)
      if ( flag == 0 ) return

      if ( flag == -1 ) then
        buf(n0:n) = real( var(:), kind(buf))
      else if ( flag == 1 ) then
        var(:) = nint( buf(n0:n) )
      else
        call stop_model("yibs_mod:copy_vars: flag .ne. 0,-1,1",255)
      endif

      end subroutine copy_vars_i_array

!*************************************************************************

!**************************************************************
!   the following two functions are all that user has to modify
!   when the list of i/o variables is changed
!   I wrote it in such a complicated way so that the list of
!   i/o variable appears only once (and is used both for input
!   and output). This prevents possible confusion due to
!   non-synchronized input and output lists.

!   i didn't include any i/o sub for cell since it looks like 
!   patch will not have any i/o vars


      subroutine copy_cell_vars(buf, n, ycell, flag)
      real*8, intent(inout) :: buf(0:)
      integer, intent(out) :: n
      !type(patch), intent(inout):: p
      type(ycelltype), intent(inout) :: ycell ! pointer ?
!@var flag defines the actual action:
!@+     -1 copy from patch to buffer
!@+      1 copy from buffer to patch
!@+      0 do nothing - just return the number of fields
      integer, intent(in) :: flag
      !---
      integer dc, i

      dc = 0

      ! include all cell variables that need i/o
      ! actually soil_texture is BC, but store it to checkpoint for now ...
      call copy_vars( buf, dc, ycell%soil_texture, flag)

      ! the following vars are from clim_stats 
      ! do we really need them ??
      call copy_vars( buf, dc, ycell%soiltemp_10d, flag)
      call copy_vars( buf, dc, ycell%airtemp_10d, flag)
      call copy_vars( buf, dc, ycell%paw_10d, flag)
      call copy_vars( buf, dc, ycell%par_10d, flag)
      call copy_vars( buf, dc, ycell%gdd, flag)
      call copy_vars( buf, dc, ycell%fdd, flag)
      call copy_vars( buf, dc, ycell%sfdd, flag)
      call copy_vars( buf, dc, ycell%ncd, flag)
      call copy_vars( buf, dc, ycell%nmd, flag)
      call copy_vars( buf, dc, ycell%nmsd, flag)
      !call copy_vars( buf, dc, ycell%ld, flag)

      call copy_vars( buf, dc, ycell%daylength(1), flag)
      call copy_vars( buf, dc, ycell%daylength(2), flag)
      call copy_vars( buf, dc, ycell%fall, flag)
      call copy_vars( buf, dc, ycell%soiltemp_ltm, flag)
      call copy_vars( buf, dc, ycell%jday_old, flag)
      call copy_vars( buf, dc, ycell%jday_tot, flag)
      call copy_vars( buf, dc, ycell%drought_state, flag)

!hacks
      call copy_vars( buf, dc, ycell%lai, flag)
      call copy_vars( buf, dc, ycell%soil_Phi, flag)
      call copy_vars( buf, dc, ycell%soil_dry, flag)
      call copy_vars( buf, dc, ycell%Qf, flag)
      call copy_vars( buf, dc, ycell%Soilmp, flag)
      !if ( flag <= 0 ) then
       call copy_vars( buf, dc, ycell%sgdd, flag)
      !endif

      n = dc

      end subroutine copy_cell_vars


      subroutine copy_patch_vars(buf, n, p, flag)
      real*8, intent(inout) :: buf(0:)
      integer, intent(out) :: n
      type(patch), intent(inout):: p
!@var flag defines the actual action:
!@+     -1 copy from patch to buffer
!@+      1 copy from buffer to patch
!@+      0 do nothing - just return the number of fields
      integer, intent(in) :: flag
      !---
      integer dc, i

      dc = 0

      ! include all patch variables that need i/o
      call copy_vars( buf, dc,  p%age,  flag )
      call copy_vars( buf, dc,  p%area, flag )
      call copy_vars( buf, dc,  p%Ci,   flag )
      do i=1,N_CASA_LAYERS      !need b/c Tpool now rank 3  -PK  
       call copy_vars( buf, dc,  p%Tpool(1,:,i),flag )
       call copy_vars( buf, dc,  p%Tpool(2,:,i),flag )
      end do
      ! not sure about the following, probably can be restored from 
      ! other data...
      call copy_vars( buf, dc,  p%soil_type, flag )
      call copy_vars( buf, dc,  p%GCANOPY, flag )
      call copy_vars( buf, dc,  p%albedo, flag )

      ! just guessing, trying to fix restart
      call copy_vars( buf, dc,  p%Reproduction, flag )
      call copy_vars( buf, dc,  p%lai, flag )

      n = dc

      end subroutine copy_patch_vars


      subroutine copy_cohort_vars(buf, n, c, flag)
      real*8, intent(inout) :: buf(0:)
      integer, intent(out) :: n
      type(cohort), intent(inout):: c
!@var flag defines the actual action:
!@+     -1 copy from patch to buffer
!@+      1 copy from buffer to patch
!@+      0 do nothing - just return the number of fields
      integer, intent(in) :: flag
      !---
      integer dc

      dc = 0

      ! include all cohort variables that need i/o
      call copy_vars( buf, dc,  c%pft,  flag )
      call copy_vars( buf, dc,  c%lai,  flag )
      call copy_vars( buf, dc,  c%h,    flag )
Cxyue
      call copy_vars( buf, dc,  c%ht_p, flag )
      call copy_vars( buf, dc,  c%lai_p, flag )
      call copy_vars( buf, dc,  c%nstep, flag )
      call copy_vars( buf, dc,  c%phen_old, flag )
      call copy_vars( buf, dc,  c%g_leaf_ac, flag )
      call copy_vars( buf, dc,  c%g_leafp_ac, flag )
      call copy_vars( buf, dc,  c%npp_ac, flag )
      call copy_vars( buf, dc,  c%resp_w_ac, flag )
      call copy_vars( buf, dc,  c%resp_p, flag )
      call copy_vars( buf, dc,  c%resp_w, flag )
      call copy_vars( buf, dc,  c%resp_r, flag )
Cxyue
      call copy_vars( buf, dc,  c%fracroot,  flag )

      ! added new data to restore checkpoint after sumcohort was removed...
      call copy_vars( buf, dc,  c%Ci,  flag )
      call copy_vars( buf, dc,  c%gcanopy,  flag )

      ! diags and hacks (added dec 9 2008)
      call copy_vars( buf, dc,  c%C_growth,  flag )
      call copy_vars( buf, dc,  c%C_growth_flux,  flag )
      call copy_vars( buf, dc,  c%C_total ,  flag )
      ! added on Mar 30 2009. Do we really need this?
      call copy_vars( buf, dc,  c%llspan  ,  flag )
      call copy_vars( buf, dc,  c%turnover_amp,  flag )
      ! needed for frost hardiness ?
      call copy_vars( buf, dc,  c%Sacclim ,  flag )

      call copy_vars( buf, dc,  c%phenofactor,  flag )
      call copy_vars( buf, dc,  c%phenofactor_c, flag )
      call copy_vars( buf, dc,  c%phenofactor_d, flag )
      call copy_vars( buf, dc,  c%phenostatus, flag )
      call copy_vars( buf, dc,  c%betad_10d,  flag )
      call copy_vars( buf, dc,  c%CB_d,  flag )
      call copy_vars( buf, dc,  c%stressH2O,  flag )
      call copy_vars( buf, dc,  c%NPP,  flag )


      n = dc

      end subroutine copy_cohort_vars

!******************************************************************



m4_loop(`
      subroutine yibs_set_forcings_`'m4_suffix`'( ycell,
     &     air_temperature, !KIM - for phenology
     &     canopy_temperature,
     &     canopy_air_humidity,      
     &     surf_pressure,            
     &     surf_CO2,                 
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
     &     surf_O3,
#endif
     &     heat_transfer_coef,       
     &     wind_speed,               
     &     total_visible_rad,
     &     direct_visible_rad,
     &     cos_solar_zenith_angle,
     &     canopy_wet_fraction,
!     &     soil_temp30cm,
!     &     soil_moist30cm,
     &     soil_temp,
     &     soil_moist,
!     &     soil_water,
     &     soil_matric_pot,
     &     soil_ice_fraction
     &     ) ! need to pass Ci, Qf ??
      type(ycelltype_public),intent(inout):: ycell`'m4_brkts(m4_ext)`'
      ! forcings probably should not be optional ...
      real*8 `'m4_arr_only(`, dimension(m4_ext)'), intent(in)  ::
     &     air_temperature, !KIM - for phenology
     &     canopy_temperature,
     &     canopy_air_humidity,
     &     surf_pressure,
     &     surf_CO2,
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
     &     surf_O3,
#endif
     &     heat_transfer_coef,
     &     wind_speed,
     &     total_visible_rad,
     &     direct_visible_rad,
     &     cos_solar_zenith_angle,
     &     canopy_wet_fraction
!     &     soil_temp30cm,
!     &     soil_moist30cm
      real*8, dimension(:m4_comma`'m4_ext`'), intent(in) ::
     &     soil_temp,
     &     soil_moist,
!     &     soil_water,
     &     soil_matric_pot,
     &     soil_ice_fraction
      !----------
      integer n
      m4_arr_only(`integer m4_ind')`'
      m4_arr_only(`integer dims(2,m4_rank)')`'

      m4_arr_only(`dims(1,:) = lbound(ycell)')`'
      m4_arr_only(`dims(2,:) = ubound(ycell)')`'
      
      !do j=1,jc
        !do i=1,ic
      m4_do(dims)
          ycell`'m4_brkts(m4_ind)`'%ycell%TairC =
     &     air_temperature`'m4_brkts(m4_ind)`' !KIM - for phenoloygy
          ycell`'m4_brkts(m4_ind)`'%ycell%TcanopyC =
     &         canopy_temperature`'m4_brkts(m4_ind)`'
          ycell`'m4_brkts(m4_ind)`'%ycell%Qf =
     &         canopy_air_humidity`'m4_brkts(m4_ind)`'
          ycell`'m4_brkts(m4_ind)`'%ycell%P_mbar =
     &         surf_pressure`'m4_brkts(m4_ind)`'
          ycell`'m4_brkts(m4_ind)`'%ycell%Ca =
     &         surf_CO2`'m4_brkts(m4_ind)`'
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
          ycell`'m4_brkts(m4_ind)`'%ycell%O3s =
     &         surf_O3`'m4_brkts(m4_ind)`'
#endif
          ycell`'m4_brkts(m4_ind)`'%ycell%Ch =
     &         heat_transfer_coef`'m4_brkts(m4_ind)`'
          ycell`'m4_brkts(m4_ind)`'%ycell%U =
     &         wind_speed`'m4_brkts(m4_ind)`'
          ycell`'m4_brkts(m4_ind)`'%ycell%IPARdif =
     &         total_visible_rad`'m4_brkts(m4_ind)`' -
     &         direct_visible_rad`'m4_brkts(m4_ind)`'
          ycell`'m4_brkts(m4_ind)`'%ycell%IPARdir =
     &         direct_visible_rad`'m4_brkts(m4_ind)`'
          ycell`'m4_brkts(m4_ind)`'%ycell%CosZen =
     &         cos_solar_zenith_angle`'m4_brkts(m4_ind)`'
          ycell`'m4_brkts(m4_ind)`'%ycell%fwet_canopy =
     &         canopy_wet_fraction`'m4_brkts(m4_ind)`'
!          ycell`'m4_brkts(m4_ind)`'%ycell%Soiltemp =
!    &      soil_temp30cm`'m4_brkts(m4_ind)`'
!          ycell`'m4_brkts(m4_ind)`'%ycell%Soilmoist =
!    &         soil_moist30cm`'m4_brkts(m4_ind)`'
!          do n=1,N_CASA_LAYERS
          do n=1,N_DEPTH
            ycell`'m4_brkts(m4_ind)`'%ycell%Soiltemp(n) =
     &           soil_temp(n`'m4_comma`'m4_ind)
            ycell`'m4_brkts(m4_ind)`'%ycell%Soilmoist(n) =
     &           soil_moist(n`'m4_comma`'m4_ind)
          end do
          do n=1,N_DEPTH
            ycell`'m4_brkts(m4_ind)`'%ycell%Soilmp(n) =
     &           soil_matric_pot(n`'m4_comma`'m4_ind)
            ycell`'m4_brkts(m4_ind)`'%ycell%fice(n) =
     &           soil_ice_fraction(n`'m4_comma`'m4_ind)
          enddo
      m4_enddo
        !enddo
      !enddo

      end subroutine yibs_set_forcings_`'m4_suffix`'
')`'


m4_loop(`
      subroutine yibs_get_exports_`'m4_suffix`'( ycell,
     &     canopy_conductance,
     &     beta_soil_layers,
     &     shortwave_transmit,
     &     leafinternal_CO2,
     &     foliage_humidity,
     &     canopy_npp,
     &     canopy_gpp,
     &     canopy_gpp0,
     &     canopy_ipp,
     &     canopy_mtp,
     &     canopy_resp_r,
     &     canopy_resp_l,
     &     canopy_resp_w,
     &     canopy_resp_p,
     &     canopy_carb_tot,
     &     canopy_carb_soil,
     &     canopy_gpp_pfts,
     &     canopy_ipp_pfts,
     &     canopy_mtp_pfts,
     &     canopy_clive_pfts,
     &     canopy_cdead_pfts,
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
     &     ozone_flux,
     &     excess_ozone_flux,
#endif
C NADINE
     &     roughness_length,
     &     flux_CO2,
     &     R_auto,
     &     albedo,
     &     canopy_max_H2O,
     &     canopy_heat_capacity,
     &     canopy_height,
     &     fraction_of_vegetated_soil,
     &     vegetation_fractions,
     &     soilresp,
     &     soilcpools,
#ifdef ACTIVE_GROWTH
     &     LAI_prognostic,
     &     height_prognostic,
     &     Phenf_pfts,
#endif
     &     LAI_pfts,
     &     height_pfts,
     &     leaf_area_index,
     &     C_total,
     &     C_ycell
     &     )
      type(ycelltype_public), intent(in) :: ycell`'m4_brkts(m4_ext)
      real*8, m4_arr_only(`dimension(m4_ext),') optional, intent(out) ::
     &     canopy_conductance,
     &     shortwave_transmit,
     &     leafinternal_CO2,
     &     foliage_humidity,
     &     canopy_npp,
     &     canopy_resp_r,
     &     canopy_resp_l,
     &     canopy_resp_w,
     &     canopy_resp_p,
     &     canopy_carb_tot,
     &     canopy_carb_soil,
     &     canopy_gpp,
     &     canopy_ipp,
     &     canopy_mtp,
     &     canopy_gpp0,
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
     &     ozone_flux,
     &     excess_ozone_flux,
#endif
C NADINE
     &     roughness_length,
     &     flux_CO2,
     &     R_auto,
     &     canopy_max_H2O,
     &     canopy_heat_capacity,
     &     canopy_height,
     &     fraction_of_vegetated_soil,
     &     soilresp,
#ifdef ACTIVE_GROWTH
     &     LAI_prognostic,
     &     height_prognostic,
#endif
     &     leaf_area_index,
     &     C_total,
     &     C_ycell
      real*8, dimension(:m4_comma`'m4_ext`'), optional, intent(out) ::
     &     beta_soil_layers,
     &     albedo,
     &     vegetation_fractions,
     &     canopy_gpp_pfts, 
     &     canopy_ipp_pfts, 
     &     canopy_mtp_pfts, 
     &     canopy_clive_pfts,
     &     canopy_cdead_pfts,
     &     LAI_pfts,
#ifdef ACTIVE_GROWTH
     &     Phenf_pfts,
#endif
     &     height_pfts
      real*8, dimension(:,:,:m4_comma`'m4_ext`'), optional, intent(out) ::
     &     soilcpools
      !----------
      integer n,p,ii
      m4_arr_only(`integer m4_ind')`'
      m4_arr_only(`integer dims(2,m4_rank)')`'

      m4_arr_only(`dims(1,:) = lbound(ycell)')`'
      m4_arr_only(`dims(2,:) = ubound(ycell)')`'

      m4_do(dims)

      if ( present(canopy_conductance) )
     &     canopy_conductance`'m4_brkts(m4_ind)`' = 
     &       ycell`'m4_brkts(m4_ind)`'%ycell%GCANOPY

      !!! Nancy, do you really nedd this ???
      m4_arr_only(`
      if( i1 > 32768 ) then
        print*,"Nancys compiler needs print stmt in yibs_mod here"
      endif
      ')`'

      if ( present(shortwave_transmit) )
     &     shortwave_transmit`'m4_brkts(m4_ind)`' = 
     &     ycell`'m4_brkts(m4_ind)`'%ycell%TRANS_SW

      if ( present(leafinternal_CO2) )
     &     leafinternal_CO2`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%Ci

      if ( present(foliage_humidity) )
     &     foliage_humidity`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%Qf

      if ( present(canopy_npp) )
     &     canopy_npp`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%NPP

      if ( present(canopy_resp_r) )
     &     canopy_resp_r`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%resp_r

      if ( present(canopy_resp_l) )
     &     canopy_resp_l`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%resp_l

      if ( present(canopy_resp_w) )
     &     canopy_resp_w`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%resp_w

      if ( present(canopy_resp_p) )
     &     canopy_resp_p`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%resp_p

      if ( present(canopy_carb_tot) )
     &     canopy_carb_tot`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%carb_tot

      if ( present(canopy_carb_soil) )
     &     canopy_carb_soil`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%carb_soil

      if ( present(canopy_gpp) )
     &     canopy_gpp`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%GPP

      if ( present(canopy_gpp0) )
     &     canopy_gpp0`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%GPP0

#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
      if ( present(ozone_flux) )
     &     ozone_flux`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%FO3

      if ( present(excess_ozone_flux) )
     &     excess_ozone_flux`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%dFO3
#endif

C NADINE
      if ( present(canopy_ipp) )
     &     canopy_ipp`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%IPP

      if ( present(canopy_mtp) )
     &     canopy_mtp`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%MTP

      if ( present(roughness_length) )
     &     roughness_length`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%z0

      if ( present(flux_CO2) )
     &     flux_CO2`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%CO2flux

      if ( present(canopy_max_H2O) )
     &     canopy_max_H2O`'m4_brkts(m4_ind)`' = 
     &     ycell`'m4_brkts(m4_ind)`'%ycell%LAI * .0001d0 !!! GISS setting

      if ( present(canopy_heat_capacity) ) then
        !aa=ala(1,i0,j0)
        !canopy_heat_capacity=(.010d0+.002d0*aa+.001d0*aa**2)*shw
        canopy_heat_capacity`'m4_brkts(m4_ind)`' =
     &       ycell`'m4_brkts(m4_ind)`'%ycell%heat_capacity
        !call stop_model("not implemmented yet",255)
      endif

      if ( present(canopy_height) ) then
        canopy_height`'m4_brkts(m4_ind)`' =
     &       ycell`'m4_brkts(m4_ind)`'%ycell%h
      endif

      if ( present(fraction_of_vegetated_soil) ) then
        ! compute it here ?
        !call stop_model("not implemmented yet",255)
        if ( associated(ycell`'m4_brkts(m4_ind)`'%ycell) ) then
          fraction_of_vegetated_soil`'m4_brkts(m4_ind)`' =
     &         ycell`'m4_brkts(m4_ind)`'%ycell%fv
        else
          fraction_of_vegetated_soil`'m4_brkts(m4_ind)`' = 0.d0
        endif
      endif

      if ( present(R_auto) )
     &     R_auto`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%R_auto

      if ( present(soilresp) )
     &     soilresp`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%Soil_resp

      if ( present(beta_soil_layers) ) then
        do n=1,N_DEPTH
          beta_soil_layers(n`'m4_comma`'m4_ind) = 
     &         ycell`'m4_brkts(m4_ind)`'%ycell%betadl(n)
        enddo
      endif

      if ( present(albedo) ) then
        do n=1,N_BANDS
          albedo(n`'m4_comma`'m4_ind) =
     &         ycell`'m4_brkts(m4_ind)`'%ycell%albedo(n)
        enddo
      endif

      if ( present(vegetation_fractions) ) then
        call ycell_extract_pfts(ycell`'m4_brkts(m4_ind)`'%ycell,
     &       vegetation_fractions(:`'m4_comma`'m4_ind))
      endif

      if ( present(soilcpools) ) then
        do n=1,N_CASA_LAYERS
         do p=1,PTRACE
          do ii=1,NPOOLS
            soilcpools(p,ii,n`'m4_comma`'m4_ind) = 
     &      ycell`'m4_brkts(m4_ind)`'%ycell%Tpool(p,ii,n)
          end do
         end do
        enddo
      endif

      if ( present(canopy_gpp_pfts) ) then
        do n = 1,N_PFT
           canopy_gpp_pfts(n+COVEROFFSET`'m4_comma`'m4_ind) =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%GPPpft(n)
        enddo
      endif

      if ( present(canopy_ipp_pfts) ) then
        do n = 1,N_PFT
           canopy_ipp_pfts(n+COVEROFFSET`'m4_comma`'m4_ind) =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%IPPpft(n)
        enddo
      endif

      if ( present(canopy_mtp_pfts) ) then
        do n = 1,N_PFT
           canopy_mtp_pfts(n+COVEROFFSET`'m4_comma`'m4_ind) =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%MTPpft(n)
        enddo
      endif

      if ( present(canopy_clive_pfts) ) then
        do n = 1,N_PFT
           canopy_clive_pfts(n+COVEROFFSET`'m4_comma`'m4_ind) =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%Clive(n)
        enddo
      endif

      if ( present(canopy_cdead_pfts) ) then
        do n = 1,N_PFT
           canopy_cdead_pfts(n+COVEROFFSET`'m4_comma`'m4_ind) =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%Cdead(n)
        enddo
      endif

      if ( present(LAI_pfts) ) then
        do n = 1,N_PFT
           LAI_pfts(n+COVEROFFSET`'m4_comma`'m4_ind) =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%laiPFT(n)
        enddo
      endif

      if ( present(height_pfts) ) then
        do n = 1,N_PFT
           height_pfts(n+COVEROFFSET`'m4_comma`'m4_ind) =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%htPFT(n)
        enddo
      endif

#ifdef ACTIVE_GROWTH
      if ( present(LAI_prognostic) )
     &     LAI_prognostic`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%lai_p

      if ( present(height_prognostic) )
     &     height_prognostic`'m4_brkts(m4_ind)`' =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%ht_p

      if ( present(Phenf_pfts) ) then
        do n = 1,N_PFT
           Phenf_pfts(n+COVEROFFSET`'m4_comma`'m4_ind) =
     &     ycell`'m4_brkts(m4_ind)`'%ycell%Phenfpft(n)
        enddo
      endif

#endif

      if ( present(leaf_area_index) )
     &     leaf_area_index`'m4_brkts(m4_ind)`' = 
     &     ycell`'m4_brkts(m4_ind)`'%ycell%LAI

      if ( present(C_total) )
     &     C_total`'m4_brkts(m4_ind)`' = 
     &     ycell`'m4_brkts(m4_ind)`'%ycell%C_total

      if ( present(C_ycell) ) then
        if ( associated(ycell`'m4_brkts(m4_ind)`'%ycell) ) then
          C_ycell`'m4_brkts(m4_ind)`' = 
     &     ycell_carbon( ycell`'m4_brkts(m4_ind)`'%ycell )
        else
	  C_ycell`'m4_brkts(m4_ind)`' = 0.d0
	endif
      endif 

      m4_enddo

      end subroutine yibs_get_exports_`'m4_suffix`'
')`'


      end module yibs_mod


