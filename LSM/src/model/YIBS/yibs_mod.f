! This file uses "f90_interface" m4 macros - plese follow corresponding rules.
! You can always look at yibs_mod.f to see how these macros were
! expanded (but don't edit that file)


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!                                                              !
!                   DO NOT EDIT THIS FILE !!!                  !
!                                                              !
! This file is generated automatically by m4 preprocessor.     !
! If you need to modyfy it plese edit corresponding *.m4f file.!
!                                                              !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!





      module yibs_mod
!@sum this module contains the interface to YIBS dynamic vegetation model
!@+   this is the only module that should be visible to GCM
 
      ! need to know about internal structure of YIBS types
      use yibs_types, only : ycelltype, patch, cohort, timestruct,
     &     MAX_PATCHES, MAX_COHORTS, yibs_config
      use yibs_const, only : N_BANDS,N_COVERTYPES
     &     , N_OTHER, COVER_SAND
     &     , N_DEPTH,N_SOIL_TEXTURES
     &     , N_BPOOLS, N_PFT, N_CASA_LAYERS,NPOOLS,NLIVE,CARBON,PTRACE
      !use yibs_prescrveg
      use ycells
      use yibs_pfts, only : CROPS,COVEROFFSET

      !use prescr_veg ! just for compilation purposes
      implicit none

      private

      !--- public constants ---
      public N_BANDS, N_COVERTYPES 
      public N_OTHER, COVER_SAND
      public N_DEPTH, N_SOIL_TEXTURES, N_BPOOLS
      public N_PFT, N_CASA_LAYERS  !added last one -PK
      public PTRACE, NPOOLS, NLIVE, CARBON  
      public yibs_config
      public CROPS,COVEROFFSET

      public ycelltype_public, yibs_cell_pack, yibs_cell_unpack
      public yibs_get_exports, yibs_set_forcings
      public yibs_cell_construct, yibs_cell_destruct, yibs_cell_nullify
      public yibs_run,yibs_vegcover_update
      public yibs_update_veg_structure
      public yibs_cell_set, yibs_cell_set_soilcarbon !, yibs_cell_update
      public yibs_prescribe_vegupdate
      public yibs_prescribe_vegupdateB
      public yibs_prescribe_vegupdateC
      public yibs_prescribe_vegupdateD
      public yibs_init_config

      public yibs_set_forcings_r8_0

      type ycelltype_public
        private
        type(ycelltype), pointer :: ycell => null()
      end type ycelltype_public

      !---- public interfaces ---

      !--- consttructor/destructor ---
      interface yibs_cell_construct
       
        module procedure yibs_cell_construct_r8_0
       
        module procedure yibs_cell_construct_r8_1
       
        module procedure yibs_cell_construct_r8_2
      
      end interface

      interface yibs_cell_destruct
      
        module procedure yibs_cell_destruct_r8_0
      
        module procedure yibs_cell_destruct_r8_1
      
        module procedure yibs_cell_destruct_r8_2
      
      end interface

      interface yibs_cell_nullify
      
        module procedure yibs_cell_nullify_r8_0
      
        module procedure yibs_cell_nullify_r8_1
      
        module procedure yibs_cell_nullify_r8_2
      
      end interface

      interface yibs_cell_pack
      module procedure yibs_cell_pack
      module procedure yibs_cell_pack_2d
      end interface

      !--- passing initial data to yibs cells ---
      interface yibs_cell_set
      
        module procedure yibs_cell_set_r8_0
      
        module procedure yibs_cell_set_r8_1
      
        module procedure yibs_cell_set_r8_2
      
      end interface

      interface yibs_cell_set_soilcarbon
      
        module procedure yibs_cell_set_soilcarbon_r8_0
      
        module procedure yibs_cell_set_soilcarbon_r8_1
      
        module procedure yibs_cell_set_soilcarbon_r8_2
      
      end interface

#ifdef MIXED_CANOPY
      public yibs_struct_setup
      !--- passing initial data to yibs cells - mixed veg ---
      interface yibs_struct_setup
      
        module procedure yibs_struct_setup_r8_0
      
        module procedure yibs_struct_setup_r8_1
      
        module procedure yibs_struct_setup_r8_2
      
      end interface

      public yibs_struct_initphys_cells
      !--- passing initial data to yibs cells - mixed veg ---
      interface yibs_struct_initphys_cells
      
        module procedure yibs_struct_initphys_cells_r8_0
      
        module procedure yibs_struct_initphys_cells_r8_1
      
        module procedure yibs_struct_initphys_cells_r8_2
      
      end interface
#endif

      !--- passing updated prescribed data to yibs cells ---
cddd      interface yibs_cell_update
cddd        module procedure yibs_cell_update_single
cddd      end interface yibs_cell_update

      !--- set forcings / get exports ---
      interface yibs_set_forcings
      
        module procedure yibs_set_forcings_r8_0
      
        module procedure yibs_set_forcings_r8_1
      
        module procedure yibs_set_forcings_r8_2
      
      end interface

      interface yibs_get_exports
      
        module procedure yibs_get_exports_r8_0
      
        module procedure yibs_get_exports_r8_1
      
        module procedure yibs_get_exports_r8_2
      
      end interface

      interface yibs_run
      
        module procedure yibs_run_r8_0
      
        module procedure yibs_run_r8_1
      
        module procedure yibs_run_r8_2
      
      end interface

      interface yibs_update_veg_structure
      
        module procedure yibs_update_veg_structure_r8_0
      
        module procedure yibs_update_veg_structure_r8_1
      
        module procedure yibs_update_veg_structure_r8_2
      
      end interface

      interface yibs_vegcover_update
      
        module procedure yibs_vegcover_update_r8_0
      
        module procedure yibs_vegcover_update_r8_1
      
        module procedure yibs_vegcover_update_r8_2
      
      end interface


!!! do we need 1d and 2d array interfaces for pack/unpack ?

      !---- private interfaces ----
      interface copy_vars
        module procedure copy_vars_single
        module procedure copy_vars_array
        module procedure copy_vars_i_single
        module procedure copy_vars_i_array
      end interface

      interface yibs_prescribe_vegupdate
      
        module procedure yibs_prescribe_vegupdate_r8_0
      
        module procedure yibs_prescribe_vegupdate_r8_1
      
        module procedure yibs_prescribe_vegupdate_r8_2
      
      end interface

      interface yibs_prescribe_vegupdateB
      
        module procedure yibs_prescribe_vegupdateB_r8_0
      
        module procedure yibs_prescribe_vegupdateB_r8_1
      
        module procedure yibs_prescribe_vegupdateB_r8_2
      
      end interface

      interface yibs_prescribe_vegupdateC
      
        module procedure yibs_prescribe_vegupdateC_r8_0
      
        module procedure yibs_prescribe_vegupdateC_r8_1
      
        module procedure yibs_prescribe_vegupdateC_r8_2
      
      end interface

      interface yibs_prescribe_vegupdateD
      
        module procedure yibs_prescribe_vegupdateD_r8_0
      
        module procedure yibs_prescribe_vegupdateD_r8_1
      
        module procedure yibs_prescribe_vegupdateD_r8_2
      
      end interface


      !---- global data ----
      type(yibs_config), save :: config

      contains

!*************************************************************************
      subroutine yibs_init_config(
     &     do_soilresp, do_phenology_activegrowth, do_structuralgrowth, 
     &     do_frost_hardiness, do_patchdynamics, do_init_geo)!, mixed_veg)
!@sum initializes YIBS module. This subroutine should set all the flags
!@+   and all the variables that are constant during the run.
      use yibs_const
      logical, optional :: do_soilresp
      logical, optional :: do_phenology_activegrowth
      logical, optional :: do_structuralgrowth
      logical, optional :: do_frost_hardiness
      logical, optional :: do_patchdynamics
      logical, optional :: do_init_geo
!      logical, optional :: mixed_veg

      print *, "initializing YIBS"
     &     , " N_DEPTH ", N_DEPTH 
     &     , " N_PFT ",  N_PFT
     &     , " N_SOILCOV ",  N_SOILCOV
     &     , " N_OTHER ",  N_OTHER
     &     , " N_COVERTYPES ",  N_COVERTYPES

      ! first set some defaults:
      config%do_soilresp = .false.
      config%do_phenology_activegrowth = .false.
      config%do_structuralgrowth = .false.
      config%do_frost_hardiness = .true.
      config%do_patchdynamics = .false.
!      config%mixed_veg = .false.

      ! now overwrite defaults with explicitly passed values
      if ( present(do_soilresp) ) config%do_soilresp = do_soilresp
      if ( present(do_phenology_activegrowth) ) 
     &     config%do_phenology_activegrowth = do_phenology_activegrowth
      if ( present(do_structuralgrowth) ) config%do_structuralgrowth = 
     &     do_structuralgrowth
      if ( present(do_frost_hardiness) ) config%do_frost_hardiness = 
     &     do_frost_hardiness
      if ( present(do_patchdynamics) ) config%do_patchdynamics = 
     &     do_patchdynamics
      if ( present(do_init_geo) ) config%do_init_geo = 
     &     do_init_geo
!      if ( present(mixed_veg) ) config%mixed_veg = mixed_veg

#ifdef ACTIVE_GROWTH
      config%do_phenology_activegrowth = .true.
      config%do_init_activegrowth = .true.
      config%do_frost_hardiness   = .true.
#endif

      end subroutine yibs_init_config

!*************************************************************************
!---- interfaces to run the model one time step --------------------------


      subroutine yibs_prescribe_vegupdate_r8_0(ycell
     &     ,hemi,jday,year,
     &     update_crops, do_giss_phenology, do_giss_lai, do_giss_albedo,
!     &     mixed_veg,
     &     laidata, hdata, albedodata, cropsdata, init)
!@sum updates prescribed vegatation parameters. This parameters can
!@+   be passed directly in form of arrays like laidata or one can
!@+   set a flag requesting certain action like do_giss_phenology.
!@+   All arguments except ycell are optional.
      use yibs_prescribed_updates, only:  ycell_vegupdate
      type(ycelltype_public),intent(inout) :: ycell 
      integer, intent(in), optional, target :: hemi 
      integer,intent(in), optional :: jday,year
      logical, intent(in), optional :: update_crops
      logical, intent(in), optional :: do_giss_phenology
      logical, intent(in), optional :: do_giss_lai
      logical, intent(in), optional :: do_giss_albedo
!      logical, intent(in), optional :: mixed_veg
      real*8, intent(in), optional, target ::
     &     laidata(:)
      real*8, intent(in), optional, target :: hdata(:)
      real*8, intent(in), optional, target ::
     &     albedodata(:,:)
      real*8, intent(in), optional, target :: cropsdata 
      logical, intent(in), optional :: init !If initialization call.
      !---
      !!!real*8, allocatable :: cropsdata_loc(:,:)
      real*8, pointer :: laidata_1(:), hdata_1(:),
     &     albedodata_1(:,:), cropsdata_1
      integer :: hemi_1, jday_1
      logical :: do_giss_phenology_1, do_giss_lai_1, do_giss_albedo_1
!      logical :: mixed_veg_1
      logical :: init_1
      
      

      
      

      if ( present(update_crops) ) then
        if ( update_crops ) then
          if ( .not. present(year) )
     &      call stop_model("yibs_prescribe_vegupdate: need year",255)
          !!!allocate ( cropsdata_loc(ic,jc) )
          ! insert call to get_crops here
          ! maybe we can avoid it ? I mean could we always
          ! pass cropdata from the driver?
        endif
      endif

      ! set defaults
      nullify( laidata_1, hdata_1, albedodata_1, cropsdata_1 )
      do_giss_phenology_1 = .false.
      do_giss_lai_1 = .true.
      do_giss_albedo_1 = .false.
!      mixed_veg_1 = .false.
      hemi_1 = -32768
      jday_1 = -32768
      init_1 = .false.

      ! now set optional arguments
      if ( present(do_giss_phenology) )
     &     do_giss_phenology_1 = do_giss_phenology
      if ( present(do_giss_lai) )
     &     do_giss_lai_1 = do_giss_lai
      if ( present(do_giss_albedo) )
     &     do_giss_albedo_1 = do_giss_albedo
!      if ( present(mixed_veg) )
!     &	   mixed_veg_1 = mixed_veg     	   		    
      if ( present(jday) ) jday_1 = jday
      if ( present(init) ) init_1 = init
         
      
          ! skip uninitialized cells (no land)
        if ( associated(ycell%ycell) ) then

          if ( present(laidata) ) laidata_1 =>
     &         laidata(:)
          if ( present(hdata) ) hdata_1 => hdata(:)
          if ( present(albedodata) ) albedodata_1 =>
     &         albedodata(:,:)
          if ( present(cropsdata) ) cropsdata_1 =>
     &         cropsdata
          if ( present(hemi) ) hemi_1 = hemi

!          write(780,*) __FILE__,__LINE__,hemi_1
          
          call ycell_vegupdate(ycell%ycell,
     &         hemi_1,
     &         jday_1, do_giss_phenology_1, do_giss_lai_1,
     &         do_giss_albedo_1, !mixed_veg_1,
     &         laidata_1, hdata_1, albedodata_1, cropsdata_1,
     &         init_1)
        endif

      
      end subroutine yibs_prescribe_vegupdate_r8_0

      subroutine yibs_prescribe_vegupdate_r8_1(ycell
     &     ,hemi,jday,year,
     &     update_crops, do_giss_phenology, do_giss_lai, do_giss_albedo,
!     &     mixed_veg,
     &     laidata, hdata, albedodata, cropsdata, init)
!@sum updates prescribed vegatation parameters. This parameters can
!@+   be passed directly in form of arrays like laidata or one can
!@+   set a flag requesting certain action like do_giss_phenology.
!@+   All arguments except ycell are optional.
      use yibs_prescribed_updates, only:  ycell_vegupdate
      type(ycelltype_public),intent(inout) :: ycell (:)
      integer, intent(in), optional, target :: hemi (:)
      integer,intent(in), optional :: jday,year
      logical, intent(in), optional :: update_crops
      logical, intent(in), optional :: do_giss_phenology
      logical, intent(in), optional :: do_giss_lai
      logical, intent(in), optional :: do_giss_albedo
!      logical, intent(in), optional :: mixed_veg
      real*8, intent(in), optional, target ::
     &     laidata(:,:)
      real*8, intent(in), optional, target :: hdata(:,:)
      real*8, intent(in), optional, target ::
     &     albedodata(:,:,:)
      real*8, intent(in), optional, target :: cropsdata (:)
      logical, intent(in), optional :: init !If initialization call.
      !---
      !!!real*8, allocatable :: cropsdata_loc(:,:)
      real*8, pointer :: laidata_1(:), hdata_1(:),
     &     albedodata_1(:,:), cropsdata_1
      integer :: hemi_1, jday_1
      logical :: do_giss_phenology_1, do_giss_lai_1, do_giss_albedo_1
!      logical :: mixed_veg_1
      logical :: init_1
      integer i1
      integer dims(2,1)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)

      if ( present(update_crops) ) then
        if ( update_crops ) then
          if ( .not. present(year) )
     &      call stop_model("yibs_prescribe_vegupdate: need year",255)
          !!!allocate ( cropsdata_loc(ic,jc) )
          ! insert call to get_crops here
          ! maybe we can avoid it ? I mean could we always
          ! pass cropdata from the driver?
        endif
      endif

      ! set defaults
      nullify( laidata_1, hdata_1, albedodata_1, cropsdata_1 )
      do_giss_phenology_1 = .false.
      do_giss_lai_1 = .true.
      do_giss_albedo_1 = .false.
!      mixed_veg_1 = .false.
      hemi_1 = -32768
      jday_1 = -32768
      init_1 = .false.

      ! now set optional arguments
      if ( present(do_giss_phenology) )
     &     do_giss_phenology_1 = do_giss_phenology
      if ( present(do_giss_lai) )
     &     do_giss_lai_1 = do_giss_lai
      if ( present(do_giss_albedo) )
     &     do_giss_albedo_1 = do_giss_albedo
!      if ( present(mixed_veg) )
!     &	   mixed_veg_1 = mixed_veg     	   		    
      if ( present(jday) ) jday_1 = jday
      if ( present(init) ) init_1 = init
         
      
      do i1=dims(1,1),dims(2,1)
          ! skip uninitialized cells (no land)
        if ( associated(ycell(i1)%ycell) ) then

          if ( present(laidata) ) laidata_1 =>
     &         laidata(:,i1)
          if ( present(hdata) ) hdata_1 => hdata(:,i1)
          if ( present(albedodata) ) albedodata_1 =>
     &         albedodata(:,:,i1)
          if ( present(cropsdata) ) cropsdata_1 =>
     &         cropsdata(i1)
          if ( present(hemi) ) hemi_1 = hemi(i1)

!          write(780,*) __FILE__,__LINE__,hemi_1
          
          call ycell_vegupdate(ycell(i1)%ycell,
     &         hemi_1,
     &         jday_1, do_giss_phenology_1, do_giss_lai_1,
     &         do_giss_albedo_1, !mixed_veg_1,
     &         laidata_1, hdata_1, albedodata_1, cropsdata_1,
     &         init_1)
        endif

      
      enddo
      end subroutine yibs_prescribe_vegupdate_r8_1

      subroutine yibs_prescribe_vegupdate_r8_2(ycell
     &     ,hemi,jday,year,
     &     update_crops, do_giss_phenology, do_giss_lai, do_giss_albedo,
!     &     mixed_veg,
     &     laidata, hdata, albedodata, cropsdata, init)
!@sum updates prescribed vegatation parameters. This parameters can
!@+   be passed directly in form of arrays like laidata or one can
!@+   set a flag requesting certain action like do_giss_phenology.
!@+   All arguments except ycell are optional.
      use yibs_prescribed_updates, only:  ycell_vegupdate
      type(ycelltype_public),intent(inout) :: ycell (:,:)
      integer, intent(in), optional, target :: hemi (:,:)
      integer,intent(in), optional :: jday,year
      logical, intent(in), optional :: update_crops
      logical, intent(in), optional :: do_giss_phenology
      logical, intent(in), optional :: do_giss_lai
      logical, intent(in), optional :: do_giss_albedo
!      logical, intent(in), optional :: mixed_veg
      real*8, intent(in), optional, target ::
     &     laidata(:,:,:)
      real*8, intent(in), optional, target :: hdata(:,:,:)
      real*8, intent(in), optional, target ::
     &     albedodata(:,:,:,:)
      real*8, intent(in), optional, target :: cropsdata (:,:)
      logical, intent(in), optional :: init !If initialization call.
      !---
      !!!real*8, allocatable :: cropsdata_loc(:,:)
      real*8, pointer :: laidata_1(:), hdata_1(:),
     &     albedodata_1(:,:), cropsdata_1
      integer :: hemi_1, jday_1
      logical :: do_giss_phenology_1, do_giss_lai_1, do_giss_albedo_1
!      logical :: mixed_veg_1
      logical :: init_1
      integer i1,i2
      integer dims(2,2)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)

      if ( present(update_crops) ) then
        if ( update_crops ) then
          if ( .not. present(year) )
     &      call stop_model("yibs_prescribe_vegupdate: need year",255)
          !!!allocate ( cropsdata_loc(ic,jc) )
          ! insert call to get_crops here
          ! maybe we can avoid it ? I mean could we always
          ! pass cropdata from the driver?
        endif
      endif

      ! set defaults
      nullify( laidata_1, hdata_1, albedodata_1, cropsdata_1 )
      do_giss_phenology_1 = .false.
      do_giss_lai_1 = .true.
      do_giss_albedo_1 = .false.
!      mixed_veg_1 = .false.
      hemi_1 = -32768
      jday_1 = -32768
      init_1 = .false.

      ! now set optional arguments
      if ( present(do_giss_phenology) )
     &     do_giss_phenology_1 = do_giss_phenology
      if ( present(do_giss_lai) )
     &     do_giss_lai_1 = do_giss_lai
      if ( present(do_giss_albedo) )
     &     do_giss_albedo_1 = do_giss_albedo
!      if ( present(mixed_veg) )
!     &	   mixed_veg_1 = mixed_veg     	   		    
      if ( present(jday) ) jday_1 = jday
      if ( present(init) ) init_1 = init
         
      
      do i1=dims(1,1),dims(2,1)
      do i2=dims(1,2),dims(2,2)
          ! skip uninitialized cells (no land)
        if ( associated(ycell(i1,i2)%ycell) ) then

          if ( present(laidata) ) laidata_1 =>
     &         laidata(:,i1,i2)
          if ( present(hdata) ) hdata_1 => hdata(:,i1,i2)
          if ( present(albedodata) ) albedodata_1 =>
     &         albedodata(:,:,i1,i2)
          if ( present(cropsdata) ) cropsdata_1 =>
     &         cropsdata(i1,i2)
          if ( present(hemi) ) hemi_1 = hemi(i1,i2)

!          write(780,*) __FILE__,__LINE__,hemi_1
          
          call ycell_vegupdate(ycell(i1,i2)%ycell,
     &         hemi_1,
     &         jday_1, do_giss_phenology_1, do_giss_lai_1,
     &         do_giss_albedo_1, !mixed_veg_1,
     &         laidata_1, hdata_1, albedodata_1, cropsdata_1,
     &         init_1)
        endif

      
      enddo
      enddo
      end subroutine yibs_prescribe_vegupdate_r8_2

     

      subroutine yibs_prescribe_vegupdateB_r8_0(ycell)
!@sum updates prescribed vegatation parameters. This parameters can
!@+   be passed directly in form of arrays like laidata or one can
!@+   set a flag requesting certain action like do_giss_phenology.
!@+   All arguments except ycell are optional.
      use yibs_prescribed_updates, only:  ycell_vegupdate
      type(ycelltype_public),intent(inout) :: ycell 
      !---
      !!!real*8, allocatable :: cropsdata_loc(:,:)
      real*8, pointer :: laidata_1(:), hdata_1(:),
     &     albedodata_1(:,:), cropsdata_1
      integer :: hemi_1, jday_1
      logical :: do_giss_phenology_1, do_giss_lai_1, do_giss_albedo_1
      logical :: init_1
      
      

      
      


      ! set defaults
      nullify( laidata_1, hdata_1, albedodata_1, cropsdata_1 )
      do_giss_phenology_1 = .false.
      do_giss_lai_1 = .true.
      do_giss_albedo_1 = .false.
      hemi_1 = -32768
      jday_1 = -32768
      init_1 = .false.

      ! now set optional arguments
         
      
          ! skip uninitialized cells (no land)
        if ( associated(ycell%ycell) ) then

!          write(780,*) __FILE__,__LINE__,hemi_1
          
          call ycell_vegupdate(ycell%ycell,
     &         hemi_1,
     &         jday_1, do_giss_phenology_1, do_giss_lai_1,
     &         do_giss_albedo_1,
     &         laidata_1, hdata_1, albedodata_1, cropsdata_1,
     &         init_1)
        endif
      

      end subroutine yibs_prescribe_vegupdateB_r8_0

      subroutine yibs_prescribe_vegupdateB_r8_1(ycell)
!@sum updates prescribed vegatation parameters. This parameters can
!@+   be passed directly in form of arrays like laidata or one can
!@+   set a flag requesting certain action like do_giss_phenology.
!@+   All arguments except ycell are optional.
      use yibs_prescribed_updates, only:  ycell_vegupdate
      type(ycelltype_public),intent(inout) :: ycell (:)
      !---
      !!!real*8, allocatable :: cropsdata_loc(:,:)
      real*8, pointer :: laidata_1(:), hdata_1(:),
     &     albedodata_1(:,:), cropsdata_1
      integer :: hemi_1, jday_1
      logical :: do_giss_phenology_1, do_giss_lai_1, do_giss_albedo_1
      logical :: init_1
      integer i1
      integer dims(2,1)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)


      ! set defaults
      nullify( laidata_1, hdata_1, albedodata_1, cropsdata_1 )
      do_giss_phenology_1 = .false.
      do_giss_lai_1 = .true.
      do_giss_albedo_1 = .false.
      hemi_1 = -32768
      jday_1 = -32768
      init_1 = .false.

      ! now set optional arguments
         
      
      do i1=dims(1,1),dims(2,1)
          ! skip uninitialized cells (no land)
        if ( associated(ycell(i1)%ycell) ) then

!          write(780,*) __FILE__,__LINE__,hemi_1
          
          call ycell_vegupdate(ycell(i1)%ycell,
     &         hemi_1,
     &         jday_1, do_giss_phenology_1, do_giss_lai_1,
     &         do_giss_albedo_1,
     &         laidata_1, hdata_1, albedodata_1, cropsdata_1,
     &         init_1)
        endif
      
      enddo

      end subroutine yibs_prescribe_vegupdateB_r8_1

      subroutine yibs_prescribe_vegupdateB_r8_2(ycell)
!@sum updates prescribed vegatation parameters. This parameters can
!@+   be passed directly in form of arrays like laidata or one can
!@+   set a flag requesting certain action like do_giss_phenology.
!@+   All arguments except ycell are optional.
      use yibs_prescribed_updates, only:  ycell_vegupdate
      type(ycelltype_public),intent(inout) :: ycell (:,:)
      !---
      !!!real*8, allocatable :: cropsdata_loc(:,:)
      real*8, pointer :: laidata_1(:), hdata_1(:),
     &     albedodata_1(:,:), cropsdata_1
      integer :: hemi_1, jday_1
      logical :: do_giss_phenology_1, do_giss_lai_1, do_giss_albedo_1
      logical :: init_1
      integer i1,i2
      integer dims(2,2)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)


      ! set defaults
      nullify( laidata_1, hdata_1, albedodata_1, cropsdata_1 )
      do_giss_phenology_1 = .false.
      do_giss_lai_1 = .true.
      do_giss_albedo_1 = .false.
      hemi_1 = -32768
      jday_1 = -32768
      init_1 = .false.

      ! now set optional arguments
         
      
      do i1=dims(1,1),dims(2,1)
      do i2=dims(1,2),dims(2,2)
          ! skip uninitialized cells (no land)
        if ( associated(ycell(i1,i2)%ycell) ) then

!          write(780,*) __FILE__,__LINE__,hemi_1
          
          call ycell_vegupdate(ycell(i1,i2)%ycell,
     &         hemi_1,
     &         jday_1, do_giss_phenology_1, do_giss_lai_1,
     &         do_giss_albedo_1,
     &         laidata_1, hdata_1, albedodata_1, cropsdata_1,
     &         init_1)
        endif
      
      enddo
      enddo

      end subroutine yibs_prescribe_vegupdateB_r8_2

     

      subroutine yibs_prescribe_vegupdateC_r8_0(ycell
     &     ,hemi,jday,year,
     &     do_giss_phenology, do_giss_albedo, do_giss_lai, 
     &     update_crops)
!@sum updates prescribed vegatation parameters. This parameters can
!@+   be passed directly in form of arrays like laidata or one can
!@+   set a flag requesting certain action like do_giss_phenology.
!@+   All arguments except ycell are optional.
      use yibs_prescribed_updates, only:  ycell_vegupdate
      type(ycelltype_public),intent(inout) :: ycell 
      integer, intent(in), target :: hemi 
      integer,intent(in) :: jday,year
      logical, intent(in) :: update_crops
      logical, intent(in) :: do_giss_phenology
      logical, intent(in) :: do_giss_lai
      logical, intent(in) :: do_giss_albedo
      !---
      !!!real*8, allocatable :: cropsdata_loc(:,:)
      real*8, pointer :: laidata_1(:), hdata_1(:),
     &     albedodata_1(:,:), cropsdata_1
      integer :: hemi_1, jday_1
      logical :: do_giss_phenology_1, do_giss_lai_1, do_giss_albedo_1
      logical :: init_1
      
      

      
      

      ! set defaults
      nullify( laidata_1, hdata_1, albedodata_1, cropsdata_1 )
      do_giss_phenology_1 = .false.
      do_giss_lai_1 = .true.
      do_giss_albedo_1 = .false.
      hemi_1 = -32768
      jday_1 = -32768
      init_1 = .false.

      ! now set optional arguments
          do_giss_phenology_1 = do_giss_phenology
          do_giss_lai_1 = do_giss_lai
          do_giss_albedo_1 = do_giss_albedo
          jday_1 = jday
         
      
          ! skip uninitialized cells (no land)
        if ( associated(ycell%ycell) ) then

           hemi_1 = hemi
!          write(780,*) __FILE__,__LINE__,hemi_1
          
          call ycell_vegupdate(ycell%ycell,
     &         hemi_1,
     &         jday_1, do_giss_phenology_1, do_giss_lai_1,
     &         do_giss_albedo_1,
     &         laidata_1, hdata_1, albedodata_1, cropsdata_1,
     &         init_1)
        endif
      

      end subroutine yibs_prescribe_vegupdateC_r8_0

      subroutine yibs_prescribe_vegupdateC_r8_1(ycell
     &     ,hemi,jday,year,
     &     do_giss_phenology, do_giss_albedo, do_giss_lai, 
     &     update_crops)
!@sum updates prescribed vegatation parameters. This parameters can
!@+   be passed directly in form of arrays like laidata or one can
!@+   set a flag requesting certain action like do_giss_phenology.
!@+   All arguments except ycell are optional.
      use yibs_prescribed_updates, only:  ycell_vegupdate
      type(ycelltype_public),intent(inout) :: ycell (:)
      integer, intent(in), target :: hemi (:)
      integer,intent(in) :: jday,year
      logical, intent(in) :: update_crops
      logical, intent(in) :: do_giss_phenology
      logical, intent(in) :: do_giss_lai
      logical, intent(in) :: do_giss_albedo
      !---
      !!!real*8, allocatable :: cropsdata_loc(:,:)
      real*8, pointer :: laidata_1(:), hdata_1(:),
     &     albedodata_1(:,:), cropsdata_1
      integer :: hemi_1, jday_1
      logical :: do_giss_phenology_1, do_giss_lai_1, do_giss_albedo_1
      logical :: init_1
      integer i1
      integer dims(2,1)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)

      ! set defaults
      nullify( laidata_1, hdata_1, albedodata_1, cropsdata_1 )
      do_giss_phenology_1 = .false.
      do_giss_lai_1 = .true.
      do_giss_albedo_1 = .false.
      hemi_1 = -32768
      jday_1 = -32768
      init_1 = .false.

      ! now set optional arguments
          do_giss_phenology_1 = do_giss_phenology
          do_giss_lai_1 = do_giss_lai
          do_giss_albedo_1 = do_giss_albedo
          jday_1 = jday
         
      
      do i1=dims(1,1),dims(2,1)
          ! skip uninitialized cells (no land)
        if ( associated(ycell(i1)%ycell) ) then

           hemi_1 = hemi(i1)
!          write(780,*) __FILE__,__LINE__,hemi_1
          
          call ycell_vegupdate(ycell(i1)%ycell,
     &         hemi_1,
     &         jday_1, do_giss_phenology_1, do_giss_lai_1,
     &         do_giss_albedo_1,
     &         laidata_1, hdata_1, albedodata_1, cropsdata_1,
     &         init_1)
        endif
      
      enddo

      end subroutine yibs_prescribe_vegupdateC_r8_1

      subroutine yibs_prescribe_vegupdateC_r8_2(ycell
     &     ,hemi,jday,year,
     &     do_giss_phenology, do_giss_albedo, do_giss_lai, 
     &     update_crops)
!@sum updates prescribed vegatation parameters. This parameters can
!@+   be passed directly in form of arrays like laidata or one can
!@+   set a flag requesting certain action like do_giss_phenology.
!@+   All arguments except ycell are optional.
      use yibs_prescribed_updates, only:  ycell_vegupdate
      type(ycelltype_public),intent(inout) :: ycell (:,:)
      integer, intent(in), target :: hemi (:,:)
      integer,intent(in) :: jday,year
      logical, intent(in) :: update_crops
      logical, intent(in) :: do_giss_phenology
      logical, intent(in) :: do_giss_lai
      logical, intent(in) :: do_giss_albedo
      !---
      !!!real*8, allocatable :: cropsdata_loc(:,:)
      real*8, pointer :: laidata_1(:), hdata_1(:),
     &     albedodata_1(:,:), cropsdata_1
      integer :: hemi_1, jday_1
      logical :: do_giss_phenology_1, do_giss_lai_1, do_giss_albedo_1
      logical :: init_1
      integer i1,i2
      integer dims(2,2)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)

      ! set defaults
      nullify( laidata_1, hdata_1, albedodata_1, cropsdata_1 )
      do_giss_phenology_1 = .false.
      do_giss_lai_1 = .true.
      do_giss_albedo_1 = .false.
      hemi_1 = -32768
      jday_1 = -32768
      init_1 = .false.

      ! now set optional arguments
          do_giss_phenology_1 = do_giss_phenology
          do_giss_lai_1 = do_giss_lai
          do_giss_albedo_1 = do_giss_albedo
          jday_1 = jday
         
      
      do i1=dims(1,1),dims(2,1)
      do i2=dims(1,2),dims(2,2)
          ! skip uninitialized cells (no land)
        if ( associated(ycell(i1,i2)%ycell) ) then

           hemi_1 = hemi(i1,i2)
!          write(780,*) __FILE__,__LINE__,hemi_1
          
          call ycell_vegupdate(ycell(i1,i2)%ycell,
     &         hemi_1,
     &         jday_1, do_giss_phenology_1, do_giss_lai_1,
     &         do_giss_albedo_1,
     &         laidata_1, hdata_1, albedodata_1, cropsdata_1,
     &         init_1)
        endif
      
      enddo
      enddo

      end subroutine yibs_prescribe_vegupdateC_r8_2

     

      subroutine yibs_prescribe_vegupdateD_r8_0(ycell,
     &     laidata, albedodata)
!@sum updates prescribed vegatation parameters. This parameters can
!@+   be passed directly in form of arrays like laidata or one can
!@+   set a flag requesting certain action like do_giss_phenology.
!@+   All arguments except ycell are optional.
      use yibs_prescribed_updates, only:  ycell_vegupdate
      type(ycelltype_public),intent(inout) :: ycell 
      real*8, intent(in), optional, target ::
     &     laidata(:)
      real*8, intent(in), optional, target ::
     &     albedodata(:,:)
      !---
      !!!real*8, allocatable :: cropsdata_loc(:,:)
      real*8, pointer :: laidata_1(:), hdata_1(:),
     &     albedodata_1(:,:), cropsdata_1
      integer :: hemi_1, jday_1
      logical :: do_giss_phenology_1, do_giss_lai_1, do_giss_albedo_1
      logical :: init_1
      
      

      
      

      ! set defaults
      nullify( laidata_1, hdata_1, albedodata_1, cropsdata_1 )
      do_giss_phenology_1 = .false.
      do_giss_lai_1 = .false.
      do_giss_albedo_1 = .false.
      hemi_1 = -32768
      jday_1 = -32768
      init_1 = .false.

      ! now set optional arguments
      
          ! skip uninitialized cells (no land)
        if ( associated(ycell%ycell) ) then

          if (present(laidata)) laidata_1 => laidata(:)
          if (present(albedodata)) albedodata_1 => albedodata(:,:)

!          write(780,*) __FILE__,__LINE__,hemi_1
          
          call ycell_vegupdate(ycell%ycell,
     &         hemi_1,
     &         jday_1, do_giss_phenology_1, do_giss_lai_1,
     &         do_giss_albedo_1,
     &         laidata_1, hdata_1, albedodata_1, cropsdata_1,
     &         init_1)
        endif
      

      end subroutine yibs_prescribe_vegupdateD_r8_0

      subroutine yibs_prescribe_vegupdateD_r8_1(ycell,
     &     laidata, albedodata)
!@sum updates prescribed vegatation parameters. This parameters can
!@+   be passed directly in form of arrays like laidata or one can
!@+   set a flag requesting certain action like do_giss_phenology.
!@+   All arguments except ycell are optional.
      use yibs_prescribed_updates, only:  ycell_vegupdate
      type(ycelltype_public),intent(inout) :: ycell (:)
      real*8, intent(in), optional, target ::
     &     laidata(:,:)
      real*8, intent(in), optional, target ::
     &     albedodata(:,:,:)
      !---
      !!!real*8, allocatable :: cropsdata_loc(:,:)
      real*8, pointer :: laidata_1(:), hdata_1(:),
     &     albedodata_1(:,:), cropsdata_1
      integer :: hemi_1, jday_1
      logical :: do_giss_phenology_1, do_giss_lai_1, do_giss_albedo_1
      logical :: init_1
      integer i1
      integer dims(2,1)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)

      ! set defaults
      nullify( laidata_1, hdata_1, albedodata_1, cropsdata_1 )
      do_giss_phenology_1 = .false.
      do_giss_lai_1 = .false.
      do_giss_albedo_1 = .false.
      hemi_1 = -32768
      jday_1 = -32768
      init_1 = .false.

      ! now set optional arguments
      
      do i1=dims(1,1),dims(2,1)
          ! skip uninitialized cells (no land)
        if ( associated(ycell(i1)%ycell) ) then

          if (present(laidata)) laidata_1 => laidata(:,i1)
          if (present(albedodata)) albedodata_1 => albedodata(:,:,i1)

!          write(780,*) __FILE__,__LINE__,hemi_1
          
          call ycell_vegupdate(ycell(i1)%ycell,
     &         hemi_1,
     &         jday_1, do_giss_phenology_1, do_giss_lai_1,
     &         do_giss_albedo_1,
     &         laidata_1, hdata_1, albedodata_1, cropsdata_1,
     &         init_1)
        endif
      
      enddo

      end subroutine yibs_prescribe_vegupdateD_r8_1

      subroutine yibs_prescribe_vegupdateD_r8_2(ycell,
     &     laidata, albedodata)
!@sum updates prescribed vegatation parameters. This parameters can
!@+   be passed directly in form of arrays like laidata or one can
!@+   set a flag requesting certain action like do_giss_phenology.
!@+   All arguments except ycell are optional.
      use yibs_prescribed_updates, only:  ycell_vegupdate
      type(ycelltype_public),intent(inout) :: ycell (:,:)
      real*8, intent(in), optional, target ::
     &     laidata(:,:,:)
      real*8, intent(in), optional, target ::
     &     albedodata(:,:,:,:)
      !---
      !!!real*8, allocatable :: cropsdata_loc(:,:)
      real*8, pointer :: laidata_1(:), hdata_1(:),
     &     albedodata_1(:,:), cropsdata_1
      integer :: hemi_1, jday_1
      logical :: do_giss_phenology_1, do_giss_lai_1, do_giss_albedo_1
      logical :: init_1
      integer i1,i2
      integer dims(2,2)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)

      ! set defaults
      nullify( laidata_1, hdata_1, albedodata_1, cropsdata_1 )
      do_giss_phenology_1 = .false.
      do_giss_lai_1 = .false.
      do_giss_albedo_1 = .false.
      hemi_1 = -32768
      jday_1 = -32768
      init_1 = .false.

      ! now set optional arguments
      
      do i1=dims(1,1),dims(2,1)
      do i2=dims(1,2),dims(2,2)
          ! skip uninitialized cells (no land)
        if ( associated(ycell(i1,i2)%ycell) ) then

          if (present(laidata)) laidata_1 => laidata(:,i1,i2)
          if (present(albedodata)) albedodata_1 => albedodata(:,:,i1,i2)

!          write(780,*) __FILE__,__LINE__,hemi_1
          
          call ycell_vegupdate(ycell(i1,i2)%ycell,
     &         hemi_1,
     &         jday_1, do_giss_phenology_1, do_giss_lai_1,
     &         do_giss_albedo_1,
     &         laidata_1, hdata_1, albedodata_1, cropsdata_1,
     &         init_1)
        endif
      
      enddo
      enddo

      end subroutine yibs_prescribe_vegupdateD_r8_2

     


      subroutine yibs_run_r8_0(ycell,dt,update_day)
      use yibs, only : yibs_integrate !yibs_integrate_GISS
!!! it is not clear yet for me how this call will be implemented ...
!@sum this call updates variable that change on a long time scale.
!@+   Right now (before real dynamic vegetation is implemented)
!@+   it should perform prescribed seasonal update of vegatation
!@+   parameters (LAI, root fraction etc.)
!@+   I think extra input parameters needed here should be passed 
!@+   as formal parameters and not be packed into ycell structure.
!@+   It seems that for prescribed variation of vegeatation
!@+   parameters we need only "jday"
!@+   Is it OK from ESMF point of view?
      !use yibs_driver, only : yibs_update_veg_structure
      type(ycelltype_public),intent(inout) :: ycell 
      real*8, intent(in) :: dt !Time step (s)
      logical, intent(in) :: update_day
!      integer, intent(in) :: jday
      !---
      
      

      
      

      
        call yibs_integrate(dt, ycell%ycell,update_day,config)
      

      end subroutine yibs_run_r8_0

      subroutine yibs_run_r8_1(ycell,dt,update_day)
      use yibs, only : yibs_integrate !yibs_integrate_GISS
!!! it is not clear yet for me how this call will be implemented ...
!@sum this call updates variable that change on a long time scale.
!@+   Right now (before real dynamic vegetation is implemented)
!@+   it should perform prescribed seasonal update of vegatation
!@+   parameters (LAI, root fraction etc.)
!@+   I think extra input parameters needed here should be passed 
!@+   as formal parameters and not be packed into ycell structure.
!@+   It seems that for prescribed variation of vegeatation
!@+   parameters we need only "jday"
!@+   Is it OK from ESMF point of view?
      !use yibs_driver, only : yibs_update_veg_structure
      type(ycelltype_public),intent(inout) :: ycell (:)
      real*8, intent(in) :: dt !Time step (s)
      logical, intent(in) :: update_day
!      integer, intent(in) :: jday
      !---
      integer i1
      integer dims(2,1)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)

      
      do i1=dims(1,1),dims(2,1)
        call yibs_integrate(dt, ycell(i1)%ycell,update_day,config)
      
      enddo

      end subroutine yibs_run_r8_1

      subroutine yibs_run_r8_2(ycell,dt,update_day)
      use yibs, only : yibs_integrate !yibs_integrate_GISS
!!! it is not clear yet for me how this call will be implemented ...
!@sum this call updates variable that change on a long time scale.
!@+   Right now (before real dynamic vegetation is implemented)
!@+   it should perform prescribed seasonal update of vegatation
!@+   parameters (LAI, root fraction etc.)
!@+   I think extra input parameters needed here should be passed 
!@+   as formal parameters and not be packed into ycell structure.
!@+   It seems that for prescribed variation of vegeatation
!@+   parameters we need only "jday"
!@+   Is it OK from ESMF point of view?
      !use yibs_driver, only : yibs_update_veg_structure
      type(ycelltype_public),intent(inout) :: ycell (:,:)
      real*8, intent(in) :: dt !Time step (s)
      logical, intent(in) :: update_day
!      integer, intent(in) :: jday
      !---
      integer i1,i2
      integer dims(2,2)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)

      
      do i1=dims(1,1),dims(2,1)
      do i2=dims(1,2),dims(2,2)
        call yibs_integrate(dt, ycell(i1,i2)%ycell,update_day,config)
      
      enddo
      enddo

      end subroutine yibs_run_r8_2





      subroutine yibs_update_veg_structure_r8_0(ycell)
      use yibs, only : update_veg_structure !yibs_integrate_GISS
!!! it is not clear yet for me how this call will be implemented ...
!@sum this call updates variable that change on a long time scale.
!@+   Right now (before real dynamic vegetation is implemented)
!@+   it should perform prescribed seasonal update of vegatation
!@+   parameters (LAI, root fraction etc.)
!@+   I think extra input parameters needed here should be passed 
!@+   as formal parameters and not be packed into ycell structure.
!@+   It seems that for prescribed variation of vegeatation
!@+   parameters we need only "jday"
!@+   Is it OK from ESMF point of view?
      !use yibs_driver, only : yibs_update_veg_structure
      type(ycelltype_public),intent(inout) :: ycell 
!      integer, intent(in) :: jday
      !---
      
      

      
      

      
        call update_veg_structure(
     &     ycell%ycell,config)
      

      end subroutine yibs_update_veg_structure_r8_0

      subroutine yibs_update_veg_structure_r8_1(ycell)
      use yibs, only : update_veg_structure !yibs_integrate_GISS
!!! it is not clear yet for me how this call will be implemented ...
!@sum this call updates variable that change on a long time scale.
!@+   Right now (before real dynamic vegetation is implemented)
!@+   it should perform prescribed seasonal update of vegatation
!@+   parameters (LAI, root fraction etc.)
!@+   I think extra input parameters needed here should be passed 
!@+   as formal parameters and not be packed into ycell structure.
!@+   It seems that for prescribed variation of vegeatation
!@+   parameters we need only "jday"
!@+   Is it OK from ESMF point of view?
      !use yibs_driver, only : yibs_update_veg_structure
      type(ycelltype_public),intent(inout) :: ycell (:)
!      integer, intent(in) :: jday
      !---
      integer i1
      integer dims(2,1)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)

      
      do i1=dims(1,1),dims(2,1)
        call update_veg_structure(
     &     ycell(i1)%ycell,config)
      
      enddo

      end subroutine yibs_update_veg_structure_r8_1

      subroutine yibs_update_veg_structure_r8_2(ycell)
      use yibs, only : update_veg_structure !yibs_integrate_GISS
!!! it is not clear yet for me how this call will be implemented ...
!@sum this call updates variable that change on a long time scale.
!@+   Right now (before real dynamic vegetation is implemented)
!@+   it should perform prescribed seasonal update of vegatation
!@+   parameters (LAI, root fraction etc.)
!@+   I think extra input parameters needed here should be passed 
!@+   as formal parameters and not be packed into ycell structure.
!@+   It seems that for prescribed variation of vegeatation
!@+   parameters we need only "jday"
!@+   Is it OK from ESMF point of view?
      !use yibs_driver, only : yibs_update_veg_structure
      type(ycelltype_public),intent(inout) :: ycell (:,:)
!      integer, intent(in) :: jday
      !---
      integer i1,i2
      integer dims(2,2)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)

      
      do i1=dims(1,1),dims(2,1)
      do i2=dims(1,2),dims(2,2)
        call update_veg_structure(
     &     ycell(i1,i2)%ycell,config)
      
      enddo
      enddo

      end subroutine yibs_update_veg_structure_r8_2









      subroutine yibs_vegcover_update_r8_0(ycell, jday, jyear)
      type(ycelltype_public),intent(inout) :: ycell 
      integer, intent(in) :: jday, jyear
      !---      
      
      

      
      
 
      
        ! no code for vegcover_update yet ...
      

      end subroutine yibs_vegcover_update_r8_0

      subroutine yibs_vegcover_update_r8_1(ycell, jday, jyear)
      type(ycelltype_public),intent(inout) :: ycell (:)
      integer, intent(in) :: jday, jyear
      !---      
      integer i1
      integer dims(2,1)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)
 
      
      do i1=dims(1,1),dims(2,1)
        ! no code for vegcover_update yet ...
      
      enddo

      end subroutine yibs_vegcover_update_r8_1

      subroutine yibs_vegcover_update_r8_2(ycell, jday, jyear)
      type(ycelltype_public),intent(inout) :: ycell (:,:)
      integer, intent(in) :: jday, jyear
      !---      
      integer i1,i2
      integer dims(2,2)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)
 
      
      do i1=dims(1,1),dims(2,1)
      do i2=dims(1,2),dims(2,2)
        ! no code for vegcover_update yet ...
      
      enddo
      enddo

      end subroutine yibs_vegcover_update_r8_2


!---- END interfaces to run the model one time step ----

!---- Constructor / Destructor -------------------------------------------


      subroutine yibs_cell_construct_r8_0(ycell)
      type(ycelltype_public),intent(inout) :: ycell 
      
      

      
      
 
      
        call ycell_construct( ycell%ycell )
      

      end subroutine yibs_cell_construct_r8_0

      subroutine yibs_cell_construct_r8_1(ycell)
      type(ycelltype_public),intent(inout) :: ycell (:)
      integer i1
      integer dims(2,1)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)
 
      
      do i1=dims(1,1),dims(2,1)
        call ycell_construct( ycell(i1)%ycell )
      
      enddo

      end subroutine yibs_cell_construct_r8_1

      subroutine yibs_cell_construct_r8_2(ycell)
      type(ycelltype_public),intent(inout) :: ycell (:,:)
      integer i1,i2
      integer dims(2,2)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)
 
      
      do i1=dims(1,1),dims(2,1)
      do i2=dims(1,2),dims(2,2)
        call ycell_construct( ycell(i1,i2)%ycell )
      
      enddo
      enddo

      end subroutine yibs_cell_construct_r8_2



      subroutine yibs_cell_destruct_r8_0(ycell)
      type(ycelltype_public),intent(inout) :: ycell 
      
      

      
      
 
      
        call ycell_destruct( ycell%ycell )
      

      end subroutine yibs_cell_destruct_r8_0

      subroutine yibs_cell_destruct_r8_1(ycell)
      type(ycelltype_public),intent(inout) :: ycell (:)
      integer i1
      integer dims(2,1)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)
 
      
      do i1=dims(1,1),dims(2,1)
        call ycell_destruct( ycell(i1)%ycell )
      
      enddo

      end subroutine yibs_cell_destruct_r8_1

      subroutine yibs_cell_destruct_r8_2(ycell)
      type(ycelltype_public),intent(inout) :: ycell (:,:)
      integer i1,i2
      integer dims(2,2)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)
 
      
      do i1=dims(1,1),dims(2,1)
      do i2=dims(1,2),dims(2,2)
        call ycell_destruct( ycell(i1,i2)%ycell )
      
      enddo
      enddo

      end subroutine yibs_cell_destruct_r8_2




      subroutine yibs_cell_nullify_r8_0(ycell)
      type(ycelltype_public),intent(inout):: ycell 
      
      

      
      

      
        nullify( ycell%ycell )
      

      end subroutine yibs_cell_nullify_r8_0

      subroutine yibs_cell_nullify_r8_1(ycell)
      type(ycelltype_public),intent(inout):: ycell (:)
      integer i1
      integer dims(2,1)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)

      
      do i1=dims(1,1),dims(2,1)
        nullify( ycell(i1)%ycell )
      
      enddo

      end subroutine yibs_cell_nullify_r8_1

      subroutine yibs_cell_nullify_r8_2(ycell)
      type(ycelltype_public),intent(inout):: ycell (:,:)
      integer i1,i2
      integer dims(2,2)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)

      
      do i1=dims(1,1),dims(2,1)
      do i2=dims(1,2),dims(2,2)
        nullify( ycell(i1,i2)%ycell )
      
      enddo
      enddo

      end subroutine yibs_cell_nullify_r8_2


!---- END of  Constructor / Destructor -----

!*************************************************************************


      subroutine yibs_cell_set_r8_0(ycell,
     &     jdayofyear,
     &     latitude,
     &     veg_fraction,
     &     leaf_area_index,
     &     pft_heights,
     &     pft_froots,
     &     pft_soil_type,
     &     vegalbedo,
     &     soil_texture,
     &     Ci_ini, CNC_ini, Tcan_ini, Qf_ini, Tpool_ini,
     &     pdate,hdate,
     &     reinitialize)
      type(ycelltype_public),intent(inout)::
     &                            ycell
      real*8, dimension(:)  ::   ! dim=N_COVERTYPES, n
     &     veg_fraction,
     &     leaf_area_index,
     &     pft_heights
      integer :: jdayofyear
      real*8, dimension(:,:)  :: pft_froots
      integer, dimension(:)  :: pft_soil_type
      real*8, dimension(:,:)  ::  vegalbedo ! dim=N_COVERTYPES, n
      real*8, dimension(:)  ::  soil_texture ! dim=N_SOIL_TEXTURES
      real*8  ::
     &     Ci_ini, CNC_ini, Tcan_ini, Qf_ini, latitude, pdate,hdate
      real*8,dimension(:,:,:,:) :: Tpool_ini  !soil pools, in g/m2 -PK
      logical :: reinitialize
      !---
      
      

      
      

      
          !print *,"yibs_cell_set_array_2d i,j=",i,j
        if ( associated(ycell%ycell) ) then
!      if ( .not. associated(ecp) ) 
!     &      call stop_model("init_simple_ycell 1",255)
          !call ycell_print(6,ycell%ycell)

          call init_simple_ycell( ycell%ycell,
     &         jdayofyear,
     &         latitude,
     &         veg_fraction(:),
     &         leaf_area_index(:),
     &         pft_heights(:),
     &         pft_froots,
     &         pft_soil_type,vegalbedo(:,:),
     &         soil_texture(:),
     &         Ci_ini, CNC_ini,
     &         Tcan_ini, Qf_ini,
     &         Tpool_ini(:,:,:,:),
     &         pdate,hdate,
     &         reinitialize)
        endif
      

      end subroutine yibs_cell_set_r8_0

      subroutine yibs_cell_set_r8_1(ycell,
     &     jdayofyear,
     &     latitude,
     &     veg_fraction,
     &     leaf_area_index,
     &     pft_heights,
     &     pft_froots,
     &     pft_soil_type,
     &     vegalbedo,
     &     soil_texture,
     &     Ci_ini, CNC_ini, Tcan_ini, Qf_ini, Tpool_ini,
     &     pdate,hdate,
     &     reinitialize)
      type(ycelltype_public),intent(inout)::
     &                            ycell(:)
      real*8, dimension(:,:)  ::   ! dim=N_COVERTYPES, n
     &     veg_fraction,
     &     leaf_area_index,
     &     pft_heights
      integer :: jdayofyear
      real*8, dimension(:,:)  :: pft_froots
      integer, dimension(:)  :: pft_soil_type
      real*8, dimension(:,:,:)  ::  vegalbedo ! dim=N_COVERTYPES, n
      real*8, dimension(:,:)  ::  soil_texture ! dim=N_SOIL_TEXTURES
      real*8 ,dimension(:) ::
     &     Ci_ini, CNC_ini, Tcan_ini, Qf_ini, latitude, pdate,hdate
      real*8,dimension(:,:,:,:,:) :: Tpool_ini  !soil pools, in g/m2 -PK
      logical :: reinitialize
      !---
      integer i1
      integer dims(2,1)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)

      
      do i1=dims(1,1),dims(2,1)
          !print *,"yibs_cell_set_array_2d i,j=",i,j
        if ( associated(ycell(i1)%ycell) ) then
!      if ( .not. associated(ecp) ) 
!     &      call stop_model("init_simple_ycell 1",255)
          !call ycell_print(6,ycell(i1)%ycell)

          call init_simple_ycell( ycell(i1)%ycell,
     &         jdayofyear,
     &         latitude(i1),
     &         veg_fraction(:,i1),
     &         leaf_area_index(:,i1),
     &         pft_heights(:,i1),
     &         pft_froots,
     &         pft_soil_type,vegalbedo(:,:,i1),
     &         soil_texture(:,i1),
     &         Ci_ini(i1), CNC_ini(i1),
     &         Tcan_ini(i1), Qf_ini(i1),
     &         Tpool_ini(:,:,:,:,i1),
     &         pdate(i1),hdate(i1),
     &         reinitialize)
        endif
      
      enddo

      end subroutine yibs_cell_set_r8_1

      subroutine yibs_cell_set_r8_2(ycell,
     &     jdayofyear,
     &     latitude,
     &     veg_fraction,
     &     leaf_area_index,
     &     pft_heights,
     &     pft_froots,
     &     pft_soil_type,
     &     vegalbedo,
     &     soil_texture,
     &     Ci_ini, CNC_ini, Tcan_ini, Qf_ini, Tpool_ini,
     &     pdate,hdate,
     &     reinitialize)
      type(ycelltype_public),intent(inout)::
     &                            ycell(:,:)
      real*8, dimension(:,:,:)  ::   ! dim=N_COVERTYPES, n
     &     veg_fraction,
     &     leaf_area_index,
     &     pft_heights
      integer :: jdayofyear
      real*8, dimension(:,:)  :: pft_froots
      integer, dimension(:)  :: pft_soil_type
      real*8, dimension(:,:,:,:)  ::  vegalbedo ! dim=N_COVERTYPES, n
      real*8, dimension(:,:,:)  ::  soil_texture ! dim=N_SOIL_TEXTURES
      real*8 ,dimension(:,:) ::
     &     Ci_ini, CNC_ini, Tcan_ini, Qf_ini, latitude, pdate,hdate
      real*8,dimension(:,:,:,:,:,:) :: Tpool_ini  !soil pools, in g/m2 -PK
      logical :: reinitialize
      !---
      integer i1,i2
      integer dims(2,2)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)

      
      do i1=dims(1,1),dims(2,1)
      do i2=dims(1,2),dims(2,2)
          !print *,"yibs_cell_set_array_2d i,j=",i,j
        if ( associated(ycell(i1,i2)%ycell) ) then
!      if ( .not. associated(ecp) ) 
!     &      call stop_model("init_simple_ycell 1",255)
          !call ycell_print(6,ycell(i1,i2)%ycell)

          call init_simple_ycell( ycell(i1,i2)%ycell,
     &         jdayofyear,
     &         latitude(i1,i2),
     &         veg_fraction(:,i1,i2),
     &         leaf_area_index(:,i1,i2),
     &         pft_heights(:,i1,i2),
     &         pft_froots,
     &         pft_soil_type,vegalbedo(:,:,i1,i2),
     &         soil_texture(:,i1,i2),
     &         Ci_ini(i1,i2), CNC_ini(i1,i2),
     &         Tcan_ini(i1,i2), Qf_ini(i1,i2),
     &         Tpool_ini(:,:,:,:,i1,i2),
     &         pdate(i1,i2),hdate(i1,i2),
     &         reinitialize)
        endif
      
      enddo
      enddo

      end subroutine yibs_cell_set_r8_2


!*************************************************************************


      subroutine yibs_cell_set_soilcarbon_r8_0(ycell,
     &     Tpool_ini )
      type(ycelltype_public),intent(inout)::
     &                            ycell
      real*8,dimension(:,:,:,:) :: Tpool_ini  !g/m2 -soil C
      !---
      
      

      
      

      
          !print *,"yibs_cell_set_array_2d i,j=",i,j
        if ( associated(ycell%ycell) ) then
!      if ( .not. associated(ecp) ) 
!     &      call stop_model("assign_ycell_soilcarbon 1",255)
          !call ycell_print(6,ycell%ycell)
          call assign_ycell_soilcarbon( 
     &	  ycell%ycell,
     &         Tpool_ini(:,:,:,:) )

        endif
      

      end subroutine yibs_cell_set_soilcarbon_r8_0

      subroutine yibs_cell_set_soilcarbon_r8_1(ycell,
     &     Tpool_ini )
      type(ycelltype_public),intent(inout)::
     &                            ycell(:)
      real*8,dimension(:,:,:,:,:) :: Tpool_ini  !g/m2 -soil C
      !---
      integer i1
      integer dims(2,1)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)

      
      do i1=dims(1,1),dims(2,1)
          !print *,"yibs_cell_set_array_2d i,j=",i,j
        if ( associated(ycell(i1)%ycell) ) then
!      if ( .not. associated(ecp) ) 
!     &      call stop_model("assign_ycell_soilcarbon 1",255)
          !call ycell_print(6,ycell(i1)%ycell)
          call assign_ycell_soilcarbon( 
     &	  ycell(i1)%ycell,
     &         Tpool_ini(:,:,:,:,i1) )

        endif
      
      enddo

      end subroutine yibs_cell_set_soilcarbon_r8_1

      subroutine yibs_cell_set_soilcarbon_r8_2(ycell,
     &     Tpool_ini )
      type(ycelltype_public),intent(inout)::
     &                            ycell(:,:)
      real*8,dimension(:,:,:,:,:,:) :: Tpool_ini  !g/m2 -soil C
      !---
      integer i1,i2
      integer dims(2,2)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)

      
      do i1=dims(1,1),dims(2,1)
      do i2=dims(1,2),dims(2,2)
          !print *,"yibs_cell_set_array_2d i,j=",i,j
        if ( associated(ycell(i1,i2)%ycell) ) then
!      if ( .not. associated(ecp) ) 
!     &      call stop_model("assign_ycell_soilcarbon 1",255)
          !call ycell_print(6,ycell(i1,i2)%ycell)
          call assign_ycell_soilcarbon( 
     &	  ycell(i1,i2)%ycell,
     &         Tpool_ini(:,:,:,:,i1,i2) )

        endif
      
      enddo
      enddo

      end subroutine yibs_cell_set_soilcarbon_r8_2



!*************************************************************************

      subroutine yibs_cell_pack_2d(dbuf, ycell)
!@sum allocate single linear arrays dbuf and pack contents of
!@+   ycells(i,j) into it
      real*8, pointer :: dbuf(:)
      type(ycelltype_public), intent(in) :: ycell(:,:)
      !---
      type real8_ptr
        real*8, pointer :: ptr(:)
      end type real8_ptr
      type(real8_ptr), dimension(:,:), allocatable :: buf2d
      integer i, j, ic, jc, dc, dcc, lsize

      ic = size(ycell, 1)
      jc = size(ycell, 2)

      allocate( buf2d(ic,jc) )
      
      dc = 0
      do j=1,jc
        do i=1,ic
          !print *,"yibs_cell_pack_2d i,j=",i,j
          nullify( buf2d(i,j)%ptr )
          if ( .not. associated(ycell(i,j)%ycell) ) cycle

          call yibs_cell_pack(buf2d(i,j)%ptr, ycell(i,j))
          dc = dc + size(buf2d(i,j)%ptr, 1) + 3 ! 3 =: i,j,size
          
        enddo
      enddo

      allocate( dbuf(dc) )
      dcc = 1
      do j=1,jc
        do i=1,ic
          if ( .not. associated( buf2d(i,j)%ptr ) ) cycle

          !print *,"yibs_cell_pack_2d i,j,dcc,lsize=",i,j,dcc,lsize
          !print *,buf2d(i,j)%ptr(1:lsize)
          lsize = size(buf2d(i,j)%ptr, 1)
          dbuf(dcc) = i; dcc = dcc+1
          dbuf(dcc) = j; dcc = dcc+1
          dbuf(dcc) = lsize; dcc = dcc+1
          dbuf(dcc:dcc+lsize-1) = buf2d(i,j)%ptr(1:lsize)
          dcc = dcc+lsize
          deallocate( buf2d(i,j)%ptr )

        enddo
      enddo

      if ( dcc-1 .ne. dc ) call stop_model("yibs_cell_pack_2d: dcc",255)
     
      deallocate( buf2d )

      end subroutine yibs_cell_pack_2d


      subroutine yibs_cell_pack(dbuf, ycell)
!@sum allocate single linear arrays dbuf and pack contents of
!@+   ycell into it
      real*8, pointer :: dbuf(:)
      type(ycelltype_public), intent(in) :: ycell ! pointer ?
      !---
      type(ycelltype), pointer :: ecp
      type(patch), pointer :: p  !@var p current patch
      type(cohort), pointer :: c !@var current cohort
      integer :: np              !@var np number of patches in the cell
      integer :: nc(MAX_PATCHES) !@var nc number of cohorts in the patch
      integer :: dc, ndbuf, nn
      real*8, pointer :: NUL(:) !@var NULL dummy pointer

      nullify(NUL)

      ! return "-1" for not associated cells
      if ( .not. associated(ycell%ycell) ) then
        allocate( dbuf(1) )
        dbuf(1) = -1.d0;
        return
      endif

      ecp => ycell%ycell

      ! first compute number of patches and cohorts in the cell
      ! this actually can be save in the cell structure 
      ! for optimization ...
      ! also count the number of real*8 values to be saved
      ndbuf = 0
      call copy_cell_vars(NUL, nn, ecp, 0); ndbuf = ndbuf + nn
      np = 0
      p => ycell%ycell%oldest      
      do while ( associated(p) )
        np = np + 1
        if ( np > MAX_PATCHES )
     &       call stop_model("yibs_cell_pack: too many patches",255)
        call copy_patch_vars(NUL, nn, p, 0); ndbuf = ndbuf + nn
        nc(np) = 0
        c => p%tallest
        do while ( associated(c) )
          nc(np) = nc(np) + 1
          if ( nc(np) > MAX_COHORTS )
     &         call stop_model("yibs_cell_pack: too many cohorts",255)
          !save cohort
          !dbuf(dc) = c%_any_value_ ; dc = dc + 1
          call copy_cohort_vars(NUL, nn, c, 0); ndbuf = ndbuf + nn
          c => c%shorter
        enddo
        p => p%younger
      enddo

      allocate( dbuf(ndbuf+1+np) ) !i.e. num reals + num int's
      dc = 0
      dbuf(dc+1) = real( np, kind(0d0) );               dc = dc + 1
      !print *,"pack ", np, dbuf(1)
      dbuf(dc+1:dc+np) = real( nc(1:np), kind(0d0) ); dc = dc + np
      !print *,"pack1 ", nc(1:np), dbuf(2:dc) 

      ! now do the real saving
      ! no need to count patches and cohorts again, but leaving it here
      ! for a while for debugging
      ! save cell vars here (if there are any...), i.e. 
      ! call copy_cell_vars(dbuf, nn, p, -1);
      call copy_cell_vars(dbuf(dc+1:), nn, ecp, -1); dc = dc + nn
      np = 0
      p => ycell%ycell%oldest      
      do while ( associated(p) )
        np = np + 1
        if ( np > MAX_PATCHES )
     &       call stop_model("yibs_cell_pack: too many patches",255)
        !save patch
        call copy_patch_vars(dbuf(dc+1:), nn, p, -1); dc = dc + nn
        nc(np) = 0
        c => p%tallest
        do while ( associated(c) )
          nc(np) = nc(np) + 1
          if ( nc(np) > MAX_COHORTS )
     &         call stop_model("yibs_cell_pack: too many cohorts",255)
          !save cohort
          call copy_cohort_vars(dbuf(dc+1:), nn, c, -1); dc = dc + nn
         c => c%shorter
        enddo
        p => p%younger
      enddo

      if ( dbuf(1) .ne. np ) then
        print *,"GGGGGGGGGGG", np, nc(1:np), "XX", dbuf
      endif

      end subroutine yibs_cell_pack

!*************************************************************************

      subroutine yibs_cell_unpack(dbuf, ycell)
! this program is not finished yet: have to assign all the pointers
      use cohorts, only : cohort_construct
      use patches, only : patch_construct
      real*8, intent(inout) :: dbuf(0:)
      type(ycelltype_public), intent(inout) :: ycell ! pointer ?
      !---
      type(ycelltype), pointer :: ecp
      type(patch), pointer :: p, pprev  !@var p current patch
      type(cohort), pointer :: c, cprev !@var current cohort
      integer :: np              !@var np number of patches in the cell
      integer, allocatable :: nc(:) !@var nc number of cohorts in the patch
      integer dc, nn
      integer i, j
      integer npdebug, ncdebug ! these are for debuging

      dc = 0

      ! doesn't seem that we need to restore anything for the cell
      np = nint( dbuf(dc) ); dc = dc + 1
      if ( np == -1 ) return  ! no data for this cell

      allocate( nc(np) )
      nc(1:np) = nint( dbuf(dc:dc+np-1) ); dc = dc + np

      if ( np <= 0 ) return  ! nothing to restore...

      ecp => ycell%ycell

      call copy_cell_vars(dbuf(dc:), nn, ecp, 1); dc = dc + nn
      nullify( pprev )
      do i=1,np
        !allocate( p )
        call patch_construct(p, ycell%ycell, 0.d0, -1)
        call copy_patch_vars(dbuf(dc:), nn, p, 1); dc = dc + nn
        p%older => pprev
        nullify( cprev)
        do j=1,nc(i)
          !allocate( c )
          call cohort_construct(c, p)
          call copy_cohort_vars(dbuf(dc:), nn, c, 1); dc = dc + nn
          c%taller => cprev
          cprev => c
        enddo
        p%shortest => cprev
        pprev => p
      enddo
      ycell%ycell%youngest => p

      ! now restore pointer lists in opposite direction
      npdebug = 0
      nullify( pprev )
      p => ycell%ycell%youngest
      do while ( associated(p) )
        p%younger => pprev
        p%cellptr => ycell%ycell
        npdebug = npdebug + 1
        if ( npdebug > np )
     &     call stop_model("yibs_cell_unpack: broken struct: np",255)
        ncdebug = 0
        nullify( cprev)
        c => p%shortest
        do while ( associated(c) )
          c%shorter => cprev
          c%pptr => p
          c%cellptr => ycell%ycell
          ncdebug = ncdebug + 1
          if ( ncdebug > nc(np-npdebug+1) )
     &      call stop_model("yibs_cell_unpack: broken struct: nc",255)
          cprev => c
          c => c%taller
        enddo
        p%tallest => cprev
        pprev => p
        p => p%older
      enddo
      ycell%ycell%oldest => pprev

      deallocate( nc )

      call summarize_ycell(ycell%ycell)

      end subroutine yibs_cell_unpack

!*************************************************************************

      subroutine copy_vars_single( buf, n, var, flag )
!@copy variable to/from buffer
!@+   !!! may need to write similar for arrays and create an interface
!@+   !!! in that case "n" will have non-trivial value
      real*8, intent(inout) :: buf(:)
      integer, intent(inout) :: n
      real*8, intent(inout):: var
!@var flag defines the actual action:
!@+     -1 copy from var to buffer
!@+      1 copy from buffer to var
!@+      0 do nothing - just return the cumulative number of elements
      integer, intent(in) :: flag
      !---
      
      n = n + 1
      if ( flag == 0 ) return

      if ( flag == -1 ) then
        buf(n) = var
      else if ( flag == 1 ) then
        var = buf(n)
      else
        call stop_model("yibs_mod:copy_vars: flag .ne. 0,-1,1",255)
      endif

      end subroutine copy_vars_single

      subroutine copy_vars_array( buf, n, var, flag )
!@copy variable to/from buffer
!@+   !!! may need to write similar for arrays and create an interface
!@+   !!! in that case "n" will have non-triial value
      real*8, intent(inout) :: buf(:)
      integer, intent(inout) :: n
      real*8, intent(inout):: var(:)
!@var flag defines the actual action:
!@+     -1 copy from var to buffer
!@+      1 copy from buffer to var
!@+      0 do nothing - just return the number of fields
      integer, intent(in) :: flag
      !---
      integer :: n0
      
      n0 = n + 1
      n = n + size(var)

      if ( flag == 0 ) return

      
      if ( flag == -1 ) then
        buf(n0:n) = var(:)
      else if ( flag == 1 ) then
        var(:) = buf(n0:n)
      else
        call stop_model("yibs_mod:copy_vars: flag .ne. 0,-1,1",255)
      endif

      end subroutine copy_vars_array

      subroutine copy_vars_i_single( buf, n, var, flag )
!@copy variable to/from buffer
!@+   !!! may need to write similar for arrays and create an interface
!@+   !!! in that case "n" will have non-triial value
      real*8, intent(inout) :: buf(:)
      integer, intent(inout) :: n
      integer, intent(inout):: var
!@var flag defines the actual action:
!@+     -1 copy from var to buffer
!@+      1 copy from buffer to var
!@+      0 do nothing - just return the number of fields
      integer, intent(in) :: flag
      !---
      
      n = n + 1
      if ( flag == 0 ) return

      if ( flag == -1 ) then
        buf(n) = real( var, kind(buf) )
      else if ( flag == 1 ) then
        var = nint( buf(n) )
      else
        call stop_model("yibs_mod:copy_vars: flag .ne. 0,-1,1",255)
      endif

      end subroutine copy_vars_i_single

      subroutine copy_vars_i_array( buf, n, var, flag )
!@copy variable to/from buffer
!@+   !!! may need to write similar for arrays and create an interface
!@+   !!! in that case "n" will have non-triial value
      real*8, intent(inout) :: buf(:)
      integer, intent(inout) :: n
      integer, intent(inout):: var(:)
!@var flag defines the actual action:
!@+     -1 copy from var to buffer
!@+      1 copy from buffer to var
!@+      0 do nothing - just return the number of fields
      integer, intent(in) :: flag
      !---
      integer :: n0
      
      n0 = n + 1
      n = n + size(var)
      if ( flag == 0 ) return

      if ( flag == -1 ) then
        buf(n0:n) = real( var(:), kind(buf))
      else if ( flag == 1 ) then
        var(:) = nint( buf(n0:n) )
      else
        call stop_model("yibs_mod:copy_vars: flag .ne. 0,-1,1",255)
      endif

      end subroutine copy_vars_i_array

!*************************************************************************

!**************************************************************
!   the following two functions are all that user has to modify
!   when the list of i/o variables is changed
!   I wrote it in such a complicated way so that the list of
!   i/o variable appears only once (and is used both for input
!   and output). This prevents possible confusion due to
!   non-synchronized input and output lists.

!   i didn't include any i/o sub for cell since it looks like 
!   patch will not have any i/o vars


      subroutine copy_cell_vars(buf, n, ycell, flag)
      real*8, intent(inout) :: buf(0:)
      integer, intent(out) :: n
      !type(patch), intent(inout):: p
      type(ycelltype), intent(inout) :: ycell ! pointer ?
!@var flag defines the actual action:
!@+     -1 copy from patch to buffer
!@+      1 copy from buffer to patch
!@+      0 do nothing - just return the number of fields
      integer, intent(in) :: flag
      !---
      integer dc, i

      dc = 0

      ! include all cell variables that need i/o
      ! actually soil_texture is BC, but store it to checkpoint for now ...
      call copy_vars( buf, dc, ycell%soil_texture, flag)

      ! the following vars are from clim_stats 
      ! do we really need them ??
      call copy_vars( buf, dc, ycell%soiltemp_10d, flag)
      call copy_vars( buf, dc, ycell%airtemp_10d, flag)
      call copy_vars( buf, dc, ycell%paw_10d, flag)
      call copy_vars( buf, dc, ycell%par_10d, flag)
      call copy_vars( buf, dc, ycell%gdd, flag)
      call copy_vars( buf, dc, ycell%fdd, flag)
      call copy_vars( buf, dc, ycell%sfdd, flag)
      call copy_vars( buf, dc, ycell%ncd, flag)
      call copy_vars( buf, dc, ycell%nmd, flag)
      call copy_vars( buf, dc, ycell%nmsd, flag)
      !call copy_vars( buf, dc, ycell%ld, flag)

      call copy_vars( buf, dc, ycell%daylength(1), flag)
      call copy_vars( buf, dc, ycell%daylength(2), flag)
      call copy_vars( buf, dc, ycell%fall, flag)
      call copy_vars( buf, dc, ycell%soiltemp_ltm, flag)
      call copy_vars( buf, dc, ycell%jday_old, flag)
      call copy_vars( buf, dc, ycell%jday_tot, flag)
      call copy_vars( buf, dc, ycell%drought_state, flag)

!hacks
      call copy_vars( buf, dc, ycell%lai, flag)
      call copy_vars( buf, dc, ycell%soil_Phi, flag)
      call copy_vars( buf, dc, ycell%soil_dry, flag)
      call copy_vars( buf, dc, ycell%Qf, flag)
      call copy_vars( buf, dc, ycell%Soilmp, flag)
      !if ( flag <= 0 ) then
       call copy_vars( buf, dc, ycell%sgdd, flag)
      !endif

      n = dc

      end subroutine copy_cell_vars


      subroutine copy_patch_vars(buf, n, p, flag)
      real*8, intent(inout) :: buf(0:)
      integer, intent(out) :: n
      type(patch), intent(inout):: p
!@var flag defines the actual action:
!@+     -1 copy from patch to buffer
!@+      1 copy from buffer to patch
!@+      0 do nothing - just return the number of fields
      integer, intent(in) :: flag
      !---
      integer dc, i

      dc = 0

      ! include all patch variables that need i/o
      call copy_vars( buf, dc,  p%age,  flag )
      call copy_vars( buf, dc,  p%area, flag )
      call copy_vars( buf, dc,  p%Ci,   flag )
      do i=1,N_CASA_LAYERS      !need b/c Tpool now rank 3  -PK  
       call copy_vars( buf, dc,  p%Tpool(1,:,i),flag )
       call copy_vars( buf, dc,  p%Tpool(2,:,i),flag )
      end do
      ! not sure about the following, probably can be restored from 
      ! other data...
      call copy_vars( buf, dc,  p%soil_type, flag )
      call copy_vars( buf, dc,  p%GCANOPY, flag )
      call copy_vars( buf, dc,  p%albedo, flag )

      ! just guessing, trying to fix restart
      call copy_vars( buf, dc,  p%Reproduction, flag )
      call copy_vars( buf, dc,  p%lai, flag )

      n = dc

      end subroutine copy_patch_vars


      subroutine copy_cohort_vars(buf, n, c, flag)
      real*8, intent(inout) :: buf(0:)
      integer, intent(out) :: n
      type(cohort), intent(inout):: c
!@var flag defines the actual action:
!@+     -1 copy from patch to buffer
!@+      1 copy from buffer to patch
!@+      0 do nothing - just return the number of fields
      integer, intent(in) :: flag
      !---
      integer dc

      dc = 0

      ! include all cohort variables that need i/o
      call copy_vars( buf, dc,  c%pft,  flag )
      call copy_vars( buf, dc,  c%lai,  flag )
      call copy_vars( buf, dc,  c%h,    flag )
Cxyue
      call copy_vars( buf, dc,  c%ht_p, flag )
      call copy_vars( buf, dc,  c%lai_p, flag )
      call copy_vars( buf, dc,  c%nstep, flag )
      call copy_vars( buf, dc,  c%phen_old, flag )
      call copy_vars( buf, dc,  c%g_leaf_ac, flag )
      call copy_vars( buf, dc,  c%g_leafp_ac, flag )
      call copy_vars( buf, dc,  c%npp_ac, flag )
      call copy_vars( buf, dc,  c%resp_w_ac, flag )
      call copy_vars( buf, dc,  c%resp_p, flag )
      call copy_vars( buf, dc,  c%resp_w, flag )
      call copy_vars( buf, dc,  c%resp_r, flag )
Cxyue
      call copy_vars( buf, dc,  c%fracroot,  flag )

      ! added new data to restore checkpoint after sumcohort was removed...
      call copy_vars( buf, dc,  c%Ci,  flag )
      call copy_vars( buf, dc,  c%gcanopy,  flag )

      ! diags and hacks (added dec 9 2008)
      call copy_vars( buf, dc,  c%C_growth,  flag )
      call copy_vars( buf, dc,  c%C_growth_flux,  flag )
      call copy_vars( buf, dc,  c%C_total ,  flag )
      ! added on Mar 30 2009. Do we really need this?
      call copy_vars( buf, dc,  c%llspan  ,  flag )
      call copy_vars( buf, dc,  c%turnover_amp,  flag )
      ! needed for frost hardiness ?
      call copy_vars( buf, dc,  c%Sacclim ,  flag )

      call copy_vars( buf, dc,  c%phenofactor,  flag )
      call copy_vars( buf, dc,  c%phenofactor_c, flag )
      call copy_vars( buf, dc,  c%phenofactor_d, flag )
      call copy_vars( buf, dc,  c%phenostatus, flag )
      call copy_vars( buf, dc,  c%betad_10d,  flag )
      call copy_vars( buf, dc,  c%CB_d,  flag )
      call copy_vars( buf, dc,  c%stressH2O,  flag )
      call copy_vars( buf, dc,  c%NPP,  flag )


      n = dc

      end subroutine copy_cohort_vars

!******************************************************************




      subroutine yibs_set_forcings_r8_0( ycell,
     &     air_temperature, !KIM - for phenology
     &     canopy_temperature,
     &     canopy_air_humidity,      
     &     surf_pressure,            
     &     surf_CO2,                 
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
     &     surf_O3,
#endif
     &     heat_transfer_coef,       
     &     wind_speed,               
     &     total_visible_rad,
     &     direct_visible_rad,
     &     cos_solar_zenith_angle,
     &     canopy_wet_fraction,
!     &     soil_temp30cm,
!     &     soil_moist30cm,
     &     soil_temp,
     &     soil_moist,
!     &     soil_water,
     &     soil_matric_pot,
     &     soil_ice_fraction
     &     ) ! need to pass Ci, Qf ??
      type(ycelltype_public),intent(inout):: ycell
      ! forcings probably should not be optional ...
      real*8 , intent(in)  ::
     &     air_temperature, !KIM - for phenology
     &     canopy_temperature,
     &     canopy_air_humidity,
     &     surf_pressure,
     &     surf_CO2,
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
     &     surf_O3,
#endif
     &     heat_transfer_coef,
     &     wind_speed,
     &     total_visible_rad,
     &     direct_visible_rad,
     &     cos_solar_zenith_angle,
     &     canopy_wet_fraction
!     &     soil_temp30cm,
!     &     soil_moist30cm
      real*8, dimension(:), intent(in) ::
     &     soil_temp,
     &     soil_moist,
!     &     soil_water,
     &     soil_matric_pot,
     &     soil_ice_fraction
      !----------
      integer n
      
      

      
      
      
      !do j=1,jc
        !do i=1,ic
      
          ycell%ycell%TairC =
     &     air_temperature !KIM - for phenoloygy
          ycell%ycell%TcanopyC =
     &         canopy_temperature
          ycell%ycell%Qf =
     &         canopy_air_humidity
          ycell%ycell%P_mbar =
     &         surf_pressure
          ycell%ycell%Ca =
     &         surf_CO2
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
          ycell%ycell%O3s =
     &         surf_O3
#endif
          ycell%ycell%Ch =
     &         heat_transfer_coef
          ycell%ycell%U =
     &         wind_speed
          ycell%ycell%IPARdif =
     &         total_visible_rad -
     &         direct_visible_rad
          ycell%ycell%IPARdir =
     &         direct_visible_rad
          ycell%ycell%CosZen =
     &         cos_solar_zenith_angle
          ycell%ycell%fwet_canopy =
     &         canopy_wet_fraction
!          ycell%ycell%Soiltemp =
!    &      soil_temp30cm
!          ycell%ycell%Soilmoist =
!    &         soil_moist30cm
!          do n=1,N_CASA_LAYERS
          do n=1,N_DEPTH
            ycell%ycell%Soiltemp(n) =
     &           soil_temp(n)
            ycell%ycell%Soilmoist(n) =
     &           soil_moist(n)
          end do
          do n=1,N_DEPTH
            ycell%ycell%Soilmp(n) =
     &           soil_matric_pot(n)
            ycell%ycell%fice(n) =
     &           soil_ice_fraction(n)
          enddo
      
        !enddo
      !enddo

      end subroutine yibs_set_forcings_r8_0

      subroutine yibs_set_forcings_r8_1( ycell,
     &     air_temperature, !KIM - for phenology
     &     canopy_temperature,
     &     canopy_air_humidity,      
     &     surf_pressure,            
     &     surf_CO2,                 
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
     &     surf_O3,
#endif
     &     heat_transfer_coef,       
     &     wind_speed,               
     &     total_visible_rad,
     &     direct_visible_rad,
     &     cos_solar_zenith_angle,
     &     canopy_wet_fraction,
!     &     soil_temp30cm,
!     &     soil_moist30cm,
     &     soil_temp,
     &     soil_moist,
!     &     soil_water,
     &     soil_matric_pot,
     &     soil_ice_fraction
     &     ) ! need to pass Ci, Qf ??
      type(ycelltype_public),intent(inout):: ycell(:)
      ! forcings probably should not be optional ...
      real*8 ,dimension(:), intent(in)  ::
     &     air_temperature, !KIM - for phenology
     &     canopy_temperature,
     &     canopy_air_humidity,
     &     surf_pressure,
     &     surf_CO2,
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
     &     surf_O3,
#endif
     &     heat_transfer_coef,
     &     wind_speed,
     &     total_visible_rad,
     &     direct_visible_rad,
     &     cos_solar_zenith_angle,
     &     canopy_wet_fraction
!     &     soil_temp30cm,
!     &     soil_moist30cm
      real*8, dimension(:,:), intent(in) ::
     &     soil_temp,
     &     soil_moist,
!     &     soil_water,
     &     soil_matric_pot,
     &     soil_ice_fraction
      !----------
      integer n
      integer i1
      integer dims(2,1)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)
      
      !do j=1,jc
        !do i=1,ic
      
      do i1=dims(1,1),dims(2,1)
          ycell(i1)%ycell%TairC =
     &     air_temperature(i1) !KIM - for phenoloygy
          ycell(i1)%ycell%TcanopyC =
     &         canopy_temperature(i1)
          ycell(i1)%ycell%Qf =
     &         canopy_air_humidity(i1)
          ycell(i1)%ycell%P_mbar =
     &         surf_pressure(i1)
          ycell(i1)%ycell%Ca =
     &         surf_CO2(i1)
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
          ycell(i1)%ycell%O3s =
     &         surf_O3(i1)
#endif
          ycell(i1)%ycell%Ch =
     &         heat_transfer_coef(i1)
          ycell(i1)%ycell%U =
     &         wind_speed(i1)
          ycell(i1)%ycell%IPARdif =
     &         total_visible_rad(i1) -
     &         direct_visible_rad(i1)
          ycell(i1)%ycell%IPARdir =
     &         direct_visible_rad(i1)
          ycell(i1)%ycell%CosZen =
     &         cos_solar_zenith_angle(i1)
          ycell(i1)%ycell%fwet_canopy =
     &         canopy_wet_fraction(i1)
!          ycell(i1)%ycell%Soiltemp =
!    &      soil_temp30cm(i1)
!          ycell(i1)%ycell%Soilmoist =
!    &         soil_moist30cm(i1)
!          do n=1,N_CASA_LAYERS
          do n=1,N_DEPTH
            ycell(i1)%ycell%Soiltemp(n) =
     &           soil_temp(n,i1)
            ycell(i1)%ycell%Soilmoist(n) =
     &           soil_moist(n,i1)
          end do
          do n=1,N_DEPTH
            ycell(i1)%ycell%Soilmp(n) =
     &           soil_matric_pot(n,i1)
            ycell(i1)%ycell%fice(n) =
     &           soil_ice_fraction(n,i1)
          enddo
      
      enddo
        !enddo
      !enddo

      end subroutine yibs_set_forcings_r8_1

      subroutine yibs_set_forcings_r8_2( ycell,
     &     air_temperature, !KIM - for phenology
     &     canopy_temperature,
     &     canopy_air_humidity,      
     &     surf_pressure,            
     &     surf_CO2,                 
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
     &     surf_O3,
#endif
     &     heat_transfer_coef,       
     &     wind_speed,               
     &     total_visible_rad,
     &     direct_visible_rad,
     &     cos_solar_zenith_angle,
     &     canopy_wet_fraction,
!     &     soil_temp30cm,
!     &     soil_moist30cm,
     &     soil_temp,
     &     soil_moist,
!     &     soil_water,
     &     soil_matric_pot,
     &     soil_ice_fraction
     &     ) ! need to pass Ci, Qf ??
      type(ycelltype_public),intent(inout):: ycell(:,:)
      ! forcings probably should not be optional ...
      real*8 ,dimension(:,:), intent(in)  ::
     &     air_temperature, !KIM - for phenology
     &     canopy_temperature,
     &     canopy_air_humidity,
     &     surf_pressure,
     &     surf_CO2,
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
     &     surf_O3,
#endif
     &     heat_transfer_coef,
     &     wind_speed,
     &     total_visible_rad,
     &     direct_visible_rad,
     &     cos_solar_zenith_angle,
     &     canopy_wet_fraction
!     &     soil_temp30cm,
!     &     soil_moist30cm
      real*8, dimension(:,:,:), intent(in) ::
     &     soil_temp,
     &     soil_moist,
!     &     soil_water,
     &     soil_matric_pot,
     &     soil_ice_fraction
      !----------
      integer n
      integer i1,i2
      integer dims(2,2)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)
      
      !do j=1,jc
        !do i=1,ic
      
      do i1=dims(1,1),dims(2,1)
      do i2=dims(1,2),dims(2,2)
          ycell(i1,i2)%ycell%TairC =
     &     air_temperature(i1,i2) !KIM - for phenoloygy
          ycell(i1,i2)%ycell%TcanopyC =
     &         canopy_temperature(i1,i2)
          ycell(i1,i2)%ycell%Qf =
     &         canopy_air_humidity(i1,i2)
          ycell(i1,i2)%ycell%P_mbar =
     &         surf_pressure(i1,i2)
          ycell(i1,i2)%ycell%Ca =
     &         surf_CO2(i1,i2)
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
          ycell(i1,i2)%ycell%O3s =
     &         surf_O3(i1,i2)
#endif
          ycell(i1,i2)%ycell%Ch =
     &         heat_transfer_coef(i1,i2)
          ycell(i1,i2)%ycell%U =
     &         wind_speed(i1,i2)
          ycell(i1,i2)%ycell%IPARdif =
     &         total_visible_rad(i1,i2) -
     &         direct_visible_rad(i1,i2)
          ycell(i1,i2)%ycell%IPARdir =
     &         direct_visible_rad(i1,i2)
          ycell(i1,i2)%ycell%CosZen =
     &         cos_solar_zenith_angle(i1,i2)
          ycell(i1,i2)%ycell%fwet_canopy =
     &         canopy_wet_fraction(i1,i2)
!          ycell(i1,i2)%ycell%Soiltemp =
!    &      soil_temp30cm(i1,i2)
!          ycell(i1,i2)%ycell%Soilmoist =
!    &         soil_moist30cm(i1,i2)
!          do n=1,N_CASA_LAYERS
          do n=1,N_DEPTH
            ycell(i1,i2)%ycell%Soiltemp(n) =
     &           soil_temp(n,i1,i2)
            ycell(i1,i2)%ycell%Soilmoist(n) =
     &           soil_moist(n,i1,i2)
          end do
          do n=1,N_DEPTH
            ycell(i1,i2)%ycell%Soilmp(n) =
     &           soil_matric_pot(n,i1,i2)
            ycell(i1,i2)%ycell%fice(n) =
     &           soil_ice_fraction(n,i1,i2)
          enddo
      
      enddo
      enddo
        !enddo
      !enddo

      end subroutine yibs_set_forcings_r8_2




      subroutine yibs_get_exports_r8_0( ycell,
     &     canopy_conductance,
     &     beta_soil_layers,
     &     shortwave_transmit,
     &     leafinternal_CO2,
     &     foliage_humidity,
     &     canopy_npp,
     &     canopy_gpp,
     &     canopy_gpp0,
     &     canopy_ipp,
     &     canopy_mtp,
     &     canopy_resp_r,
     &     canopy_resp_l,
     &     canopy_resp_w,
     &     canopy_resp_p,
     &     canopy_carb_tot,
     &     canopy_carb_soil,
     &     canopy_gpp_pfts,
     &     canopy_ipp_pfts,
     &     canopy_mtp_pfts,
     &     canopy_clive_pfts,
     &     canopy_cdead_pfts,
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
     &     ozone_flux,
     &     excess_ozone_flux,
#endif
C NADINE
     &     roughness_length,
     &     flux_CO2,
     &     R_auto,
     &     albedo,
     &     canopy_max_H2O,
     &     canopy_heat_capacity,
     &     canopy_height,
     &     fraction_of_vegetated_soil,
     &     vegetation_fractions,
     &     soilresp,
     &     soilcpools,
#ifdef ACTIVE_GROWTH
     &     LAI_prognostic,
     &     height_prognostic,
     &     Phenf_pfts,
#endif
     &     LAI_pfts,
     &     height_pfts,
     &     leaf_area_index,
     &     C_total,
     &     C_ycell
     &     )
      type(ycelltype_public), intent(in) :: ycell
      real*8,  optional, intent(out) ::
     &     canopy_conductance,
     &     shortwave_transmit,
     &     leafinternal_CO2,
     &     foliage_humidity,
     &     canopy_npp,
     &     canopy_resp_r,
     &     canopy_resp_l,
     &     canopy_resp_w,
     &     canopy_resp_p,
     &     canopy_carb_tot,
     &     canopy_carb_soil,
     &     canopy_gpp,
     &     canopy_ipp,
     &     canopy_mtp,
     &     canopy_gpp0,
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
     &     ozone_flux,
     &     excess_ozone_flux,
#endif
C NADINE
     &     roughness_length,
     &     flux_CO2,
     &     R_auto,
     &     canopy_max_H2O,
     &     canopy_heat_capacity,
     &     canopy_height,
     &     fraction_of_vegetated_soil,
     &     soilresp,
#ifdef ACTIVE_GROWTH
     &     LAI_prognostic,
     &     height_prognostic,
#endif
     &     leaf_area_index,
     &     C_total,
     &     C_ycell
      real*8, dimension(:), optional, intent(out) ::
     &     beta_soil_layers,
     &     albedo,
     &     vegetation_fractions,
     &     canopy_gpp_pfts, 
     &     canopy_ipp_pfts, 
     &     canopy_mtp_pfts, 
     &     canopy_clive_pfts,
     &     canopy_cdead_pfts,
     &     LAI_pfts,
#ifdef ACTIVE_GROWTH
     &     Phenf_pfts,
#endif
     &     height_pfts
      real*8, dimension(:,:,:), optional, intent(out) ::
     &     soilcpools
      !----------
      integer n,p,ii
      
      

      
      

      

      if ( present(canopy_conductance) )
     &     canopy_conductance = 
     &       ycell%ycell%GCANOPY

      !!! Nancy, do you really nedd this ???
      

      if ( present(shortwave_transmit) )
     &     shortwave_transmit = 
     &     ycell%ycell%TRANS_SW

      if ( present(leafinternal_CO2) )
     &     leafinternal_CO2 =
     &     ycell%ycell%Ci

      if ( present(foliage_humidity) )
     &     foliage_humidity =
     &     ycell%ycell%Qf

      if ( present(canopy_npp) )
     &     canopy_npp =
     &     ycell%ycell%NPP

      if ( present(canopy_resp_r) )
     &     canopy_resp_r =
     &     ycell%ycell%resp_r

      if ( present(canopy_resp_l) )
     &     canopy_resp_l =
     &     ycell%ycell%resp_l

      if ( present(canopy_resp_w) )
     &     canopy_resp_w =
     &     ycell%ycell%resp_w

      if ( present(canopy_resp_p) )
     &     canopy_resp_p =
     &     ycell%ycell%resp_p

      if ( present(canopy_carb_tot) )
     &     canopy_carb_tot =
     &     ycell%ycell%carb_tot

      if ( present(canopy_carb_soil) )
     &     canopy_carb_soil =
     &     ycell%ycell%carb_soil

      if ( present(canopy_gpp) )
     &     canopy_gpp =
     &     ycell%ycell%GPP

      if ( present(canopy_gpp0) )
     &     canopy_gpp0 =
     &     ycell%ycell%GPP0

#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
      if ( present(ozone_flux) )
     &     ozone_flux =
     &     ycell%ycell%FO3

      if ( present(excess_ozone_flux) )
     &     excess_ozone_flux =
     &     ycell%ycell%dFO3
#endif

C NADINE
      if ( present(canopy_ipp) )
     &     canopy_ipp =
     &     ycell%ycell%IPP

      if ( present(canopy_mtp) )
     &     canopy_mtp =
     &     ycell%ycell%MTP

      if ( present(roughness_length) )
     &     roughness_length =
     &     ycell%ycell%z0

      if ( present(flux_CO2) )
     &     flux_CO2 =
     &     ycell%ycell%CO2flux

      if ( present(canopy_max_H2O) )
     &     canopy_max_H2O = 
     &     ycell%ycell%LAI * .0001d0 !!! GISS setting

      if ( present(canopy_heat_capacity) ) then
        !aa=ala(1,i0,j0)
        !canopy_heat_capacity=(.010d0+.002d0*aa+.001d0*aa**2)*shw
        canopy_heat_capacity =
     &       ycell%ycell%heat_capacity
        !call stop_model("not implemmented yet",255)
      endif

      if ( present(canopy_height) ) then
        canopy_height =
     &       ycell%ycell%h
      endif

      if ( present(fraction_of_vegetated_soil) ) then
        ! compute it here ?
        !call stop_model("not implemmented yet",255)
        if ( associated(ycell%ycell) ) then
          fraction_of_vegetated_soil =
     &         ycell%ycell%fv
        else
          fraction_of_vegetated_soil = 0.d0
        endif
      endif

      if ( present(R_auto) )
     &     R_auto =
     &     ycell%ycell%R_auto

      if ( present(soilresp) )
     &     soilresp =
     &     ycell%ycell%Soil_resp

      if ( present(beta_soil_layers) ) then
        do n=1,N_DEPTH
          beta_soil_layers(n) = 
     &         ycell%ycell%betadl(n)
        enddo
      endif

      if ( present(albedo) ) then
        do n=1,N_BANDS
          albedo(n) =
     &         ycell%ycell%albedo(n)
        enddo
      endif

      if ( present(vegetation_fractions) ) then
        call ycell_extract_pfts(ycell%ycell,
     &       vegetation_fractions(:))
      endif

      if ( present(soilcpools) ) then
        do n=1,N_CASA_LAYERS
         do p=1,PTRACE
          do ii=1,NPOOLS
            soilcpools(p,ii,n) = 
     &      ycell%ycell%Tpool(p,ii,n)
          end do
         end do
        enddo
      endif

      if ( present(canopy_gpp_pfts) ) then
        do n = 1,N_PFT
           canopy_gpp_pfts(n+COVEROFFSET) =
     &     ycell%ycell%GPPpft(n)
        enddo
      endif

      if ( present(canopy_ipp_pfts) ) then
        do n = 1,N_PFT
           canopy_ipp_pfts(n+COVEROFFSET) =
     &     ycell%ycell%IPPpft(n)
        enddo
      endif

      if ( present(canopy_mtp_pfts) ) then
        do n = 1,N_PFT
           canopy_mtp_pfts(n+COVEROFFSET) =
     &     ycell%ycell%MTPpft(n)
        enddo
      endif

      if ( present(canopy_clive_pfts) ) then
        do n = 1,N_PFT
           canopy_clive_pfts(n+COVEROFFSET) =
     &     ycell%ycell%Clive(n)
        enddo
      endif

      if ( present(canopy_cdead_pfts) ) then
        do n = 1,N_PFT
           canopy_cdead_pfts(n+COVEROFFSET) =
     &     ycell%ycell%Cdead(n)
        enddo
      endif

      if ( present(LAI_pfts) ) then
        do n = 1,N_PFT
           LAI_pfts(n+COVEROFFSET) =
     &     ycell%ycell%laiPFT(n)
        enddo
      endif

      if ( present(height_pfts) ) then
        do n = 1,N_PFT
           height_pfts(n+COVEROFFSET) =
     &     ycell%ycell%htPFT(n)
        enddo
      endif

#ifdef ACTIVE_GROWTH
      if ( present(LAI_prognostic) )
     &     LAI_prognostic =
     &     ycell%ycell%lai_p

      if ( present(height_prognostic) )
     &     height_prognostic =
     &     ycell%ycell%ht_p

      if ( present(Phenf_pfts) ) then
        do n = 1,N_PFT
           Phenf_pfts(n+COVEROFFSET) =
     &     ycell%ycell%Phenfpft(n)
        enddo
      endif

#endif

      if ( present(leaf_area_index) )
     &     leaf_area_index = 
     &     ycell%ycell%LAI

      if ( present(C_total) )
     &     C_total = 
     &     ycell%ycell%C_total

      if ( present(C_ycell) ) then
        if ( associated(ycell%ycell) ) then
          C_ycell = 
     &     ycell_carbon( ycell%ycell )
        else
	  C_ycell = 0.d0
	endif
      endif 

      

      end subroutine yibs_get_exports_r8_0

      subroutine yibs_get_exports_r8_1( ycell,
     &     canopy_conductance,
     &     beta_soil_layers,
     &     shortwave_transmit,
     &     leafinternal_CO2,
     &     foliage_humidity,
     &     canopy_npp,
     &     canopy_gpp,
     &     canopy_gpp0,
     &     canopy_ipp,
     &     canopy_mtp,
     &     canopy_resp_r,
     &     canopy_resp_l,
     &     canopy_resp_w,
     &     canopy_resp_p,
     &     canopy_carb_tot,
     &     canopy_carb_soil,
     &     canopy_gpp_pfts,
     &     canopy_ipp_pfts,
     &     canopy_mtp_pfts,
     &     canopy_clive_pfts,
     &     canopy_cdead_pfts,
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
     &     ozone_flux,
     &     excess_ozone_flux,
#endif
C NADINE
     &     roughness_length,
     &     flux_CO2,
     &     R_auto,
     &     albedo,
     &     canopy_max_H2O,
     &     canopy_heat_capacity,
     &     canopy_height,
     &     fraction_of_vegetated_soil,
     &     vegetation_fractions,
     &     soilresp,
     &     soilcpools,
#ifdef ACTIVE_GROWTH
     &     LAI_prognostic,
     &     height_prognostic,
     &     Phenf_pfts,
#endif
     &     LAI_pfts,
     &     height_pfts,
     &     leaf_area_index,
     &     C_total,
     &     C_ycell
     &     )
      type(ycelltype_public), intent(in) :: ycell(:)
      real*8, dimension(:), optional, intent(out) ::
     &     canopy_conductance,
     &     shortwave_transmit,
     &     leafinternal_CO2,
     &     foliage_humidity,
     &     canopy_npp,
     &     canopy_resp_r,
     &     canopy_resp_l,
     &     canopy_resp_w,
     &     canopy_resp_p,
     &     canopy_carb_tot,
     &     canopy_carb_soil,
     &     canopy_gpp,
     &     canopy_ipp,
     &     canopy_mtp,
     &     canopy_gpp0,
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
     &     ozone_flux,
     &     excess_ozone_flux,
#endif
C NADINE
     &     roughness_length,
     &     flux_CO2,
     &     R_auto,
     &     canopy_max_H2O,
     &     canopy_heat_capacity,
     &     canopy_height,
     &     fraction_of_vegetated_soil,
     &     soilresp,
#ifdef ACTIVE_GROWTH
     &     LAI_prognostic,
     &     height_prognostic,
#endif
     &     leaf_area_index,
     &     C_total,
     &     C_ycell
      real*8, dimension(:,:), optional, intent(out) ::
     &     beta_soil_layers,
     &     albedo,
     &     vegetation_fractions,
     &     canopy_gpp_pfts, 
     &     canopy_ipp_pfts, 
     &     canopy_mtp_pfts, 
     &     canopy_clive_pfts,
     &     canopy_cdead_pfts,
     &     LAI_pfts,
#ifdef ACTIVE_GROWTH
     &     Phenf_pfts,
#endif
     &     height_pfts
      real*8, dimension(:,:,:,:), optional, intent(out) ::
     &     soilcpools
      !----------
      integer n,p,ii
      integer i1
      integer dims(2,1)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)

      
      do i1=dims(1,1),dims(2,1)

      if ( present(canopy_conductance) )
     &     canopy_conductance(i1) = 
     &       ycell(i1)%ycell%GCANOPY

      !!! Nancy, do you really nedd this ???
      if( i1 > 32768 ) then
        print*,"Nancys compiler needs print stmt in yibs_mod here"
      endif
      

      if ( present(shortwave_transmit) )
     &     shortwave_transmit(i1) = 
     &     ycell(i1)%ycell%TRANS_SW

      if ( present(leafinternal_CO2) )
     &     leafinternal_CO2(i1) =
     &     ycell(i1)%ycell%Ci

      if ( present(foliage_humidity) )
     &     foliage_humidity(i1) =
     &     ycell(i1)%ycell%Qf

      if ( present(canopy_npp) )
     &     canopy_npp(i1) =
     &     ycell(i1)%ycell%NPP

      if ( present(canopy_resp_r) )
     &     canopy_resp_r(i1) =
     &     ycell(i1)%ycell%resp_r

      if ( present(canopy_resp_l) )
     &     canopy_resp_l(i1) =
     &     ycell(i1)%ycell%resp_l

      if ( present(canopy_resp_w) )
     &     canopy_resp_w(i1) =
     &     ycell(i1)%ycell%resp_w

      if ( present(canopy_resp_p) )
     &     canopy_resp_p(i1) =
     &     ycell(i1)%ycell%resp_p

      if ( present(canopy_carb_tot) )
     &     canopy_carb_tot(i1) =
     &     ycell(i1)%ycell%carb_tot

      if ( present(canopy_carb_soil) )
     &     canopy_carb_soil(i1) =
     &     ycell(i1)%ycell%carb_soil

      if ( present(canopy_gpp) )
     &     canopy_gpp(i1) =
     &     ycell(i1)%ycell%GPP

      if ( present(canopy_gpp0) )
     &     canopy_gpp0(i1) =
     &     ycell(i1)%ycell%GPP0

#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
      if ( present(ozone_flux) )
     &     ozone_flux(i1) =
     &     ycell(i1)%ycell%FO3

      if ( present(excess_ozone_flux) )
     &     excess_ozone_flux(i1) =
     &     ycell(i1)%ycell%dFO3
#endif

C NADINE
      if ( present(canopy_ipp) )
     &     canopy_ipp(i1) =
     &     ycell(i1)%ycell%IPP

      if ( present(canopy_mtp) )
     &     canopy_mtp(i1) =
     &     ycell(i1)%ycell%MTP

      if ( present(roughness_length) )
     &     roughness_length(i1) =
     &     ycell(i1)%ycell%z0

      if ( present(flux_CO2) )
     &     flux_CO2(i1) =
     &     ycell(i1)%ycell%CO2flux

      if ( present(canopy_max_H2O) )
     &     canopy_max_H2O(i1) = 
     &     ycell(i1)%ycell%LAI * .0001d0 !!! GISS setting

      if ( present(canopy_heat_capacity) ) then
        !aa=ala(1,i0,j0)
        !canopy_heat_capacity=(.010d0+.002d0*aa+.001d0*aa**2)*shw
        canopy_heat_capacity(i1) =
     &       ycell(i1)%ycell%heat_capacity
        !call stop_model("not implemmented yet",255)
      endif

      if ( present(canopy_height) ) then
        canopy_height(i1) =
     &       ycell(i1)%ycell%h
      endif

      if ( present(fraction_of_vegetated_soil) ) then
        ! compute it here ?
        !call stop_model("not implemmented yet",255)
        if ( associated(ycell(i1)%ycell) ) then
          fraction_of_vegetated_soil(i1) =
     &         ycell(i1)%ycell%fv
        else
          fraction_of_vegetated_soil(i1) = 0.d0
        endif
      endif

      if ( present(R_auto) )
     &     R_auto(i1) =
     &     ycell(i1)%ycell%R_auto

      if ( present(soilresp) )
     &     soilresp(i1) =
     &     ycell(i1)%ycell%Soil_resp

      if ( present(beta_soil_layers) ) then
        do n=1,N_DEPTH
          beta_soil_layers(n,i1) = 
     &         ycell(i1)%ycell%betadl(n)
        enddo
      endif

      if ( present(albedo) ) then
        do n=1,N_BANDS
          albedo(n,i1) =
     &         ycell(i1)%ycell%albedo(n)
        enddo
      endif

      if ( present(vegetation_fractions) ) then
        call ycell_extract_pfts(ycell(i1)%ycell,
     &       vegetation_fractions(:,i1))
      endif

      if ( present(soilcpools) ) then
        do n=1,N_CASA_LAYERS
         do p=1,PTRACE
          do ii=1,NPOOLS
            soilcpools(p,ii,n,i1) = 
     &      ycell(i1)%ycell%Tpool(p,ii,n)
          end do
         end do
        enddo
      endif

      if ( present(canopy_gpp_pfts) ) then
        do n = 1,N_PFT
           canopy_gpp_pfts(n+COVEROFFSET,i1) =
     &     ycell(i1)%ycell%GPPpft(n)
        enddo
      endif

      if ( present(canopy_ipp_pfts) ) then
        do n = 1,N_PFT
           canopy_ipp_pfts(n+COVEROFFSET,i1) =
     &     ycell(i1)%ycell%IPPpft(n)
        enddo
      endif

      if ( present(canopy_mtp_pfts) ) then
        do n = 1,N_PFT
           canopy_mtp_pfts(n+COVEROFFSET,i1) =
     &     ycell(i1)%ycell%MTPpft(n)
        enddo
      endif

      if ( present(canopy_clive_pfts) ) then
        do n = 1,N_PFT
           canopy_clive_pfts(n+COVEROFFSET,i1) =
     &     ycell(i1)%ycell%Clive(n)
        enddo
      endif

      if ( present(canopy_cdead_pfts) ) then
        do n = 1,N_PFT
           canopy_cdead_pfts(n+COVEROFFSET,i1) =
     &     ycell(i1)%ycell%Cdead(n)
        enddo
      endif

      if ( present(LAI_pfts) ) then
        do n = 1,N_PFT
           LAI_pfts(n+COVEROFFSET,i1) =
     &     ycell(i1)%ycell%laiPFT(n)
        enddo
      endif

      if ( present(height_pfts) ) then
        do n = 1,N_PFT
           height_pfts(n+COVEROFFSET,i1) =
     &     ycell(i1)%ycell%htPFT(n)
        enddo
      endif

#ifdef ACTIVE_GROWTH
      if ( present(LAI_prognostic) )
     &     LAI_prognostic(i1) =
     &     ycell(i1)%ycell%lai_p

      if ( present(height_prognostic) )
     &     height_prognostic(i1) =
     &     ycell(i1)%ycell%ht_p

      if ( present(Phenf_pfts) ) then
        do n = 1,N_PFT
           Phenf_pfts(n+COVEROFFSET,i1) =
     &     ycell(i1)%ycell%Phenfpft(n)
        enddo
      endif

#endif

      if ( present(leaf_area_index) )
     &     leaf_area_index(i1) = 
     &     ycell(i1)%ycell%LAI

      if ( present(C_total) )
     &     C_total(i1) = 
     &     ycell(i1)%ycell%C_total

      if ( present(C_ycell) ) then
        if ( associated(ycell(i1)%ycell) ) then
          C_ycell(i1) = 
     &     ycell_carbon( ycell(i1)%ycell )
        else
	  C_ycell(i1) = 0.d0
	endif
      endif 

      
      enddo

      end subroutine yibs_get_exports_r8_1

      subroutine yibs_get_exports_r8_2( ycell,
     &     canopy_conductance,
     &     beta_soil_layers,
     &     shortwave_transmit,
     &     leafinternal_CO2,
     &     foliage_humidity,
     &     canopy_npp,
     &     canopy_gpp,
     &     canopy_gpp0,
     &     canopy_ipp,
     &     canopy_mtp,
     &     canopy_resp_r,
     &     canopy_resp_l,
     &     canopy_resp_w,
     &     canopy_resp_p,
     &     canopy_carb_tot,
     &     canopy_carb_soil,
     &     canopy_gpp_pfts,
     &     canopy_ipp_pfts,
     &     canopy_mtp_pfts,
     &     canopy_clive_pfts,
     &     canopy_cdead_pfts,
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
     &     ozone_flux,
     &     excess_ozone_flux,
#endif
C NADINE
     &     roughness_length,
     &     flux_CO2,
     &     R_auto,
     &     albedo,
     &     canopy_max_H2O,
     &     canopy_heat_capacity,
     &     canopy_height,
     &     fraction_of_vegetated_soil,
     &     vegetation_fractions,
     &     soilresp,
     &     soilcpools,
#ifdef ACTIVE_GROWTH
     &     LAI_prognostic,
     &     height_prognostic,
     &     Phenf_pfts,
#endif
     &     LAI_pfts,
     &     height_pfts,
     &     leaf_area_index,
     &     C_total,
     &     C_ycell
     &     )
      type(ycelltype_public), intent(in) :: ycell(:,:)
      real*8, dimension(:,:), optional, intent(out) ::
     &     canopy_conductance,
     &     shortwave_transmit,
     &     leafinternal_CO2,
     &     foliage_humidity,
     &     canopy_npp,
     &     canopy_resp_r,
     &     canopy_resp_l,
     &     canopy_resp_w,
     &     canopy_resp_p,
     &     canopy_carb_tot,
     &     canopy_carb_soil,
     &     canopy_gpp,
     &     canopy_ipp,
     &     canopy_mtp,
     &     canopy_gpp0,
#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
     &     ozone_flux,
     &     excess_ozone_flux,
#endif
C NADINE
     &     roughness_length,
     &     flux_CO2,
     &     R_auto,
     &     canopy_max_H2O,
     &     canopy_heat_capacity,
     &     canopy_height,
     &     fraction_of_vegetated_soil,
     &     soilresp,
#ifdef ACTIVE_GROWTH
     &     LAI_prognostic,
     &     height_prognostic,
#endif
     &     leaf_area_index,
     &     C_total,
     &     C_ycell
      real*8, dimension(:,:,:), optional, intent(out) ::
     &     beta_soil_layers,
     &     albedo,
     &     vegetation_fractions,
     &     canopy_gpp_pfts, 
     &     canopy_ipp_pfts, 
     &     canopy_mtp_pfts, 
     &     canopy_clive_pfts,
     &     canopy_cdead_pfts,
     &     LAI_pfts,
#ifdef ACTIVE_GROWTH
     &     Phenf_pfts,
#endif
     &     height_pfts
      real*8, dimension(:,:,:,:,:), optional, intent(out) ::
     &     soilcpools
      !----------
      integer n,p,ii
      integer i1,i2
      integer dims(2,2)

      dims(1,:) = lbound(ycell)
      dims(2,:) = ubound(ycell)

      
      do i1=dims(1,1),dims(2,1)
      do i2=dims(1,2),dims(2,2)

      if ( present(canopy_conductance) )
     &     canopy_conductance(i1,i2) = 
     &       ycell(i1,i2)%ycell%GCANOPY

      !!! Nancy, do you really nedd this ???
      if( i1 > 32768 ) then
        print*,"Nancys compiler needs print stmt in yibs_mod here"
      endif
      

      if ( present(shortwave_transmit) )
     &     shortwave_transmit(i1,i2) = 
     &     ycell(i1,i2)%ycell%TRANS_SW

      if ( present(leafinternal_CO2) )
     &     leafinternal_CO2(i1,i2) =
     &     ycell(i1,i2)%ycell%Ci

      if ( present(foliage_humidity) )
     &     foliage_humidity(i1,i2) =
     &     ycell(i1,i2)%ycell%Qf

      if ( present(canopy_npp) )
     &     canopy_npp(i1,i2) =
     &     ycell(i1,i2)%ycell%NPP

      if ( present(canopy_resp_r) )
     &     canopy_resp_r(i1,i2) =
     &     ycell(i1,i2)%ycell%resp_r

      if ( present(canopy_resp_l) )
     &     canopy_resp_l(i1,i2) =
     &     ycell(i1,i2)%ycell%resp_l

      if ( present(canopy_resp_w) )
     &     canopy_resp_w(i1,i2) =
     &     ycell(i1,i2)%ycell%resp_w

      if ( present(canopy_resp_p) )
     &     canopy_resp_p(i1,i2) =
     &     ycell(i1,i2)%ycell%resp_p

      if ( present(canopy_carb_tot) )
     &     canopy_carb_tot(i1,i2) =
     &     ycell(i1,i2)%ycell%carb_tot

      if ( present(canopy_carb_soil) )
     &     canopy_carb_soil(i1,i2) =
     &     ycell(i1,i2)%ycell%carb_soil

      if ( present(canopy_gpp) )
     &     canopy_gpp(i1,i2) =
     &     ycell(i1,i2)%ycell%GPP

      if ( present(canopy_gpp0) )
     &     canopy_gpp0(i1,i2) =
     &     ycell(i1,i2)%ycell%GPP0

#if (defined O3DEP_UPTAKE) || (defined O3DEP_UPTAKE_OFFLINE)
      if ( present(ozone_flux) )
     &     ozone_flux(i1,i2) =
     &     ycell(i1,i2)%ycell%FO3

      if ( present(excess_ozone_flux) )
     &     excess_ozone_flux(i1,i2) =
     &     ycell(i1,i2)%ycell%dFO3
#endif

C NADINE
      if ( present(canopy_ipp) )
     &     canopy_ipp(i1,i2) =
     &     ycell(i1,i2)%ycell%IPP

      if ( present(canopy_mtp) )
     &     canopy_mtp(i1,i2) =
     &     ycell(i1,i2)%ycell%MTP

      if ( present(roughness_length) )
     &     roughness_length(i1,i2) =
     &     ycell(i1,i2)%ycell%z0

      if ( present(flux_CO2) )
     &     flux_CO2(i1,i2) =
     &     ycell(i1,i2)%ycell%CO2flux

      if ( present(canopy_max_H2O) )
     &     canopy_max_H2O(i1,i2) = 
     &     ycell(i1,i2)%ycell%LAI * .0001d0 !!! GISS setting

      if ( present(canopy_heat_capacity) ) then
        !aa=ala(1,i0,j0)
        !canopy_heat_capacity=(.010d0+.002d0*aa+.001d0*aa**2)*shw
        canopy_heat_capacity(i1,i2) =
     &       ycell(i1,i2)%ycell%heat_capacity
        !call stop_model("not implemmented yet",255)
      endif

      if ( present(canopy_height) ) then
        canopy_height(i1,i2) =
     &       ycell(i1,i2)%ycell%h
      endif

      if ( present(fraction_of_vegetated_soil) ) then
        ! compute it here ?
        !call stop_model("not implemmented yet",255)
        if ( associated(ycell(i1,i2)%ycell) ) then
          fraction_of_vegetated_soil(i1,i2) =
     &         ycell(i1,i2)%ycell%fv
        else
          fraction_of_vegetated_soil(i1,i2) = 0.d0
        endif
      endif

      if ( present(R_auto) )
     &     R_auto(i1,i2) =
     &     ycell(i1,i2)%ycell%R_auto

      if ( present(soilresp) )
     &     soilresp(i1,i2) =
     &     ycell(i1,i2)%ycell%Soil_resp

      if ( present(beta_soil_layers) ) then
        do n=1,N_DEPTH
          beta_soil_layers(n,i1,i2) = 
     &         ycell(i1,i2)%ycell%betadl(n)
        enddo
      endif

      if ( present(albedo) ) then
        do n=1,N_BANDS
          albedo(n,i1,i2) =
     &         ycell(i1,i2)%ycell%albedo(n)
        enddo
      endif

      if ( present(vegetation_fractions) ) then
        call ycell_extract_pfts(ycell(i1,i2)%ycell,
     &       vegetation_fractions(:,i1,i2))
      endif

      if ( present(soilcpools) ) then
        do n=1,N_CASA_LAYERS
         do p=1,PTRACE
          do ii=1,NPOOLS
            soilcpools(p,ii,n,i1,i2) = 
     &      ycell(i1,i2)%ycell%Tpool(p,ii,n)
          end do
         end do
        enddo
      endif

      if ( present(canopy_gpp_pfts) ) then
        do n = 1,N_PFT
           canopy_gpp_pfts(n+COVEROFFSET,i1,i2) =
     &     ycell(i1,i2)%ycell%GPPpft(n)
        enddo
      endif

      if ( present(canopy_ipp_pfts) ) then
        do n = 1,N_PFT
           canopy_ipp_pfts(n+COVEROFFSET,i1,i2) =
     &     ycell(i1,i2)%ycell%IPPpft(n)
        enddo
      endif

      if ( present(canopy_mtp_pfts) ) then
        do n = 1,N_PFT
           canopy_mtp_pfts(n+COVEROFFSET,i1,i2) =
     &     ycell(i1,i2)%ycell%MTPpft(n)
        enddo
      endif

      if ( present(canopy_clive_pfts) ) then
        do n = 1,N_PFT
           canopy_clive_pfts(n+COVEROFFSET,i1,i2) =
     &     ycell(i1,i2)%ycell%Clive(n)
        enddo
      endif

      if ( present(canopy_cdead_pfts) ) then
        do n = 1,N_PFT
           canopy_cdead_pfts(n+COVEROFFSET,i1,i2) =
     &     ycell(i1,i2)%ycell%Cdead(n)
        enddo
      endif

      if ( present(LAI_pfts) ) then
        do n = 1,N_PFT
           LAI_pfts(n+COVEROFFSET,i1,i2) =
     &     ycell(i1,i2)%ycell%laiPFT(n)
        enddo
      endif

      if ( present(height_pfts) ) then
        do n = 1,N_PFT
           height_pfts(n+COVEROFFSET,i1,i2) =
     &     ycell(i1,i2)%ycell%htPFT(n)
        enddo
      endif

#ifdef ACTIVE_GROWTH
      if ( present(LAI_prognostic) )
     &     LAI_prognostic(i1,i2) =
     &     ycell(i1,i2)%ycell%lai_p

      if ( present(height_prognostic) )
     &     height_prognostic(i1,i2) =
     &     ycell(i1,i2)%ycell%ht_p

      if ( present(Phenf_pfts) ) then
        do n = 1,N_PFT
           Phenf_pfts(n+COVEROFFSET,i1,i2) =
     &     ycell(i1,i2)%ycell%Phenfpft(n)
        enddo
      endif

#endif

      if ( present(leaf_area_index) )
     &     leaf_area_index(i1,i2) = 
     &     ycell(i1,i2)%ycell%LAI

      if ( present(C_total) )
     &     C_total(i1,i2) = 
     &     ycell(i1,i2)%ycell%C_total

      if ( present(C_ycell) ) then
        if ( associated(ycell(i1,i2)%ycell) ) then
          C_ycell(i1,i2) = 
     &     ycell_carbon( ycell(i1,i2)%ycell )
        else
	  C_ycell(i1,i2) = 0.d0
	endif
      endif 

      
      enddo
      enddo

      end subroutine yibs_get_exports_r8_2



      end module yibs_mod


